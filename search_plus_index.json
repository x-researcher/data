{"./":{"url":"./","title":"Introduction","keywords":"","body":"数据科学, 学习手册 记录数据科学学习时的资料，好记性不如烂笔头，及时归纳总结，也方便查询。 数据科学的主要语言为 R 和 Python，一直非常喜欢 Python，但没有系统性的学习，将来补上这方面知识，而为了目前的科研数据分析，先学习 R 语言。 目前正在学习的课程： R 语言 [ ] R Programming [x] 1. Basic Building Blocks [x] 2. Workspace and Files [x] 3. Sequences of Numbers [x] 4. Vectors [ ] 5. Missing Values [ ] 6. Subsetting Vectors [ ] 7. Matrices and Data Frames [ ] 8. Logic [ ] 9. Functions [ ] 10. lapply and sapply [ ] 11. vapply and tapply [ ] 12. Looking at Data [ ] 13. Simulation [ ] 14. Dates and Times [ ] 15. Base Graphics Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-11 11:32:29 "},"R/RProgramming/":{"url":"R/RProgramming/","title":"R Programming","keywords":"","body":"使用 swirl 学习 R 语言 启动 R R 安装 swirl > install.packages(\"swirl\") 调用、安装课程并启动 swirl > library(\"swirl\") > install_course(\"Course Name Here\") # 课程列表参考 https://github.com/swirldev/swirl_courses > swirl() 后面就是按照提醒一步步操作，先给自己起个名字，然后选择课程。我选择的是 R Programming，最后选择课时。 swirl 的其他命令 可输入 info() 查看 > info() | When you are at the R prompt (>): | -- Typing skip() allows you to skip the current question. | -- Typing play() lets you experiment with R on your own; swirl will ignore | what you do... | -- UNTIL you type nxt() which will regain swirl's attention. | -- Typing bye() causes swirl to exit. Your progress will be saved. | -- Typing main() returns you to swirl's main menu. | -- Typing info() displays these options again. R Programming 课程目录 [x] 1. Basic Building Blocks [x] 2. Workspace and Files [x] 3. Sequences of Numbers [x] 4. Vectors [ ] 5. Missing Values [ ] 6. Subsetting Vectors [ ] 7. Matrices and Data Frames [ ] 8. Logic [ ] 9. Functions [ ] 10. lapply and sapply [ ] 11. vapply and tapply [ ] 12. Looking at Data [ ] 13. Simulation [ ] 14. Dates and Times [ ] 15. Base Graphics Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-11 11:32:29 "},"R/RProgramming/lesson1.html":{"url":"R/RProgramming/lesson1.html","title":"基本构件","keywords":"","body":"Lesson 1: 基本构件 本课时，我们将探索一些 R 语言的基本构件。 如需帮助，可以使用 help.start()。 最简单的形式，R 语言可用作交互式计算器： > 5 + 7 [1] 12 我们可以创建一个变量来储存计算结果，而不用每次都重新输入 5 + 7 ，在 R 语言中，给变量赋值使用的符号是 （小于号后面跟一个减号）。 可以把这个分配运算符看作一个箭头，把箭头右侧的值赋给左侧的变量，例如： > x 你可能注意到了，R 并没有直接输出计算结果 12，当你使用分配运算符时，R 假设你不想立即看到计算结果，而是倾向于之后要使用此计算值。如果想查看变量 x 的内容，直接输入 x，然后按 Enter， > x [1] 12 下面创建一个新变量 y ，使 y = x - 3 > y y [1] 9 使用 y 或 y ，完全取决与你的个人习惯，但是在每个分配运算符两侧各留一个 空格 是个很好的习惯。 现在，让我们创建一个称为 向量 的小的数字集合。 在 R 语言中，任何包含数据的东西都称为一个数据结构，而数值向量是最简单的数据结构类型。 最简单的创建一个向量的方式是使用 c() 函数, 它代表的意思是 concatenate 或 combine。下面创建一个包含数字 1.1，9 和 3.14 的向量 z： > z z [1] 1.10 9.00 3.14 如果对某个特定函数存在疑问，可以使用 \"?\" 命令访问 R 自带的帮助文件，例如，如果想得到 c() 函数更多的信息，可以输入 ?c 查看（不用输入括号）。 > ?c c package:base R Documentation Combine Values into a Vector or List Description: This is a generic function which combines its arguments. The default method combines its arguments to form a vector. All arguments are coerced to a common type which is the type of the returned value, and all attributes except names are removed. Usage: ... 下面我们创建一个包含 z 和 555 的新向量。 > c(z, 555) [1] 1.10 9.00 3.14 555.00 再创建一个向量 c(z, 555, z) > c(z, 555, z) [1] 1.10 9.00 3.14 555.00 1.10 9.00 3.14 数值向量能被用于算术运算。例如： > z * 2 + 100 [1] 102.20 118.00 106.28 首先是每个元素乘以 2，然后每个元素的计算结果再加上 100. 其他常见的数学运算符有 \"+\", \"-\", \"/\", 和 \"^\"(squared 平方)。使用函数 sqrt() 得到平方根，以及使用 abs() 函数得到绝对值。 创建一个新函数 my_sqrt, 求 z-1 的平方根： > my_sqrt my_sqrt [1] 0.3162278 2.8284271 1.4628739 R 首先会将向量 z 的每个元素减去 1，然后是每个结果独立开平方根，得到的是和向量 z 长度一样的新的向量。 创建一个新的向量 my_div，使其等于 向量 z 除于 my_sqrt: > my_div my_div [1] 3.478505 3.181981 2.146460 在之前的例子中，当我们计算 z * 2 + 100 时，z 是一个长度为 3 的向量，但是技术上说， 2 和 100 是长度为 1 的向量。其背后的含义是，R 再循环 制造了一个向量 2s 和一个向量 100s，换句话说，当你要求 R 计算 z 2 + 100 时，它真实计算的是：z c(2, 2, 2) + c(100, 100, 100). 为了了解 在循环 机制时如何运作的，我们看另一个例子，试着做一个运算，c(1, 2, 3, 4) + c(0, 10) > c(1, 2, 3, 4) + c(0, 10) [1] 1 12 3 14 如果长向量的长度 不是 短向量的倍数，R 仍会应用 在循环 机制，但是会弹出一个警告，让你知道有些怪怪的事情正在运行。例如，我们尝试运行 c(1, 2, 3, 4) + c(0, 10, 100) > c(1, 2, 3, 4) + c(0, 10, 100) [1] 1 12 103 4 Warning message: In c(1, 2, 3, 4) + c(0, 10, 100) : longer object length is not a multiple of shorter object length Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-10 22:36:05 "},"R/RProgramming/lesson2.html":{"url":"R/RProgramming/lesson2.html","title":"工作空间和文件","keywords":"","body":"Lesson 2: 工作空间和文件 在本节课，你将能学到，在 R 语言中如何检查你的当地工作空间，以及开始探索工作空间与机器的文件系统之间的关系。 因为不同操作系统在处理事情比如文件路径等有不同的规定，这些命令的输出结果也可能因机器而异。不管怎么说，重要的是，R 语言为与文件交互提供了一个通用 API. getwd() 获取本 R 课程当前运行的目录： > getwd() [1] \"/root\" ls() 列出您当前工作空间的所有项目： > ls() [1] \"my\" \"my_div\" \"my_sqrt\" \"mydiv\" \"x\" \"y\" \"z\" 对 x 赋值 9 > x ls() [1] \"my\" \"my_div\" \"my_sqrt\" \"mydiv\" \"x\" \"y\" \"z\" list.files() 或 dir() 列出在本工作目录下的所有文件： > list.files() [1] \"1\" \"anaconda3\" [3] \"gitback.sh\" \"gitback.sh.save\" [5] \"install.sh\" \"JupyterLab\" 使用 ?list.files 查看更多信息 args() 查看函数可以采用什么样的参数。 例如，查看 list.files() 函数可以使用什么参数： > args(list.files) function (path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) NULL 将当前工作目录赋值给变量 old.dir: > old.dir 我们可以在课程结束时用此变量返回到我们开始的地方。许多像 getwd() 这样的询问函数有个非常有用特性，可以返回问题的答案为一个函数的结果。 dir.create() 在当前工作目录下创建一个名为 testdir 的目录。 > dir.create(\"testdir\") setwd() 设置当前目录为 testdir > setwd(\"testdir\") 通常，你想设置你的工作目录为某些敏感的地方，也许需要创建你正在运行的特有项目。事实上，组织你的 R 包方面的工作，使用 RStudio 是个明智的选择。下载 Rstudio 在 http://www.rstudio.com/ file 系类函数 file.create() 在当前工作目录下创建一个名为 mytest.R 的文件： > file.create('mytest.R') [1] TRUE # 这个文件就时该工作目录下的唯一的文件，查看一下： > list.files() [1] \"mytest.R\" file.exists() 检查当前工作目录下是否存在 mytest.R 文件： > file.exists(\"mytest.R\") [1] TRUE file.info() 查看文件 mytest.R 的信息： > file.info(\"mytest.R\") size isdir mode mtime ctime mytest.R 0 FALSE 644 2020-03-09 22:49:36 2020-03-09 22:49:36 atime uid gid uname grname mytest.R 2020-03-09 22:49:36 0 0 root root 可以使用 $ 运算符，比如 file.info('mytest.R')$mode --- 获得特定的项目 file.rename() 重命名 mytest.R 为 mytest2.R > file.rename('mytest.R','mytest2.R') [1] TRUE file.copy() 备份 mytest2.R 为 mytest3.R: > file.copy('mytest2.R','mytest3.R') [1] TRUE file.remove() 移除文件 file.path() 提供某文件的相对路径： > file.path('mytest3.R') [1] \"mytest3.R\" 可以利用这个特性获得文件夹的相对路径，例如： > file.path(\"folder1\", \"folder2\") [1] \"folder1/folder2\" dir.create() ?dir.create 查看帮助文件，注意 recursive 参数，为了创建嵌套目录，recursive 应设为 TRUE. > ?dir.create files2 package:base R Documentation Manipulation of Directories and File Permissions Description: These functions provide a low-level interface to the computer's file system. Usage: dir.exists(paths) dir.create(path, showWarnings = TRUE, recursive = FALSE, mode = \"0777\") Sys.chmod(paths, mode = \"0777\", use_umask = TRUE) Sys.umask(mode = NA) Arguments: path: a character vector containing a single path name. Tilde expansion (see ‘path.expand’) is done. paths: character vectors containing file or directory paths. Tilde expansion (see ‘path.expand’) is done. showWarnings: logical; should the warnings on failure be shown? recursive: logical. Should elements of the path other than the last be created? If true, like the Unix command ‘mkdir -p’. mode: the mode to be used on Unix-alikes: it will be coerced by ‘as.octmode’. For ‘Sys.chmod’ it is recycled along ‘paths’. use_umask: logical: should the mode be restricted by the ‘umask’ setting? Details: ··· 在当前工作目录下，创建一个名为 testdir2 的文件夹，以及一个名为 testdir3 的子文件夹（这利用到之前提到的 file.path() 的特性）。 > dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE) 使用 setwd() 函数返回原来的工作目录（可重新调用之前创建的变量 old.dir） > setwd(old.dir) 这对于保存之前的设置，开始一个分析，然后在结束时返回起始位置十分有帮助。 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-10 22:36:05 "},"R/RProgramming/lesson3.html":{"url":"R/RProgramming/lesson3.html","title":"数列","keywords":"","body":"Lesson 3: 数列 这节课，学习在 R 中如何创建数列。 在 R 中，最简单的创建数列的方式是使用 : 运算符，输入 1：20 查看它是如何运作的： > 1:20 [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 它的输出值为 1-20 的所有整数。 我们也能用它创建实数数列。例如： > pi:10 [1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593 结果是从 pi 开始，递增间隔为 1 的实数向量。上限 10 是不可能达到的，因为它的下一个数据大于 10. 如果输入 15:1 会发生什么？ 试一下： > 15:1 [1] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 返回的结果为一组递减数列。 学习 R 时，有任何不清楚的函数功能，都可以通过查询 R 自带的帮助文档获得，此处查看一下':'运算符的详细信息： > ?':' The binary operator ‘:’ has two meanings: for factors ‘a:b’ is equivalent to ‘interaction(a, b)’ (but the levels are ordered and labelled differently). For other arguments ‘from:to’ is equivalent to ‘seq(from, to)’, and generates a sequence from ‘from’ to ‘to’ in steps of ‘1’ or ‘-1’. Value ‘to’ will be included if it differs from ‘from’ by an integer up to a numeric fuzz of about ‘1e-7’. Non-numeric arguments are coerced internally (hence without dispatching methods) to numeric-complex values will have their imaginary parts discarded with a warning. Value: For numeric arguments, a numeric vector. This will be of type ‘integer’ if ‘from’ is integer-valued and the result is representable in the R integer type, otherwise of type ‘\"double\"’ (aka ‘mode’ ‘\"numeric\"’). For factors, an unordered factor with levels labelled as ‘la:lb’ and ordered lexicographically (that is, ‘lb’ varies fastest). References: ··· Examples: 1:4 pi:6 # real 6:pi # integer f1 通常情况下，在创建数列时，我们想获得比 ':' 运算符提供的更多的自由度， seq() 函数可以满足我们的目的。 seq() 函数最基本的用法和 : 运算符一样，例如 seq(1, 10): > seq(1, 20) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 结果与 1:20 一致。如果要创建一个增幅为 0.5，范围在 0-10 的数列，可以使用 seq(0, 10, by=0.5) > seq(0, 10, by = 0.5) [1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 [16] 7.5 8.0 8.5 9.0 9.5 10.0 如果我们不关心增幅，只是想获得5-10范围内的30个数字，seq(5 ,10, length=30) 可以达到这个目的。尝试一下，并将结果赋值给变量 my_seq > my_seq 为了确认 my_seq 变量的长度为 30，可以使用 length() 函数。 > length(my_seq) [1] 30 假设我们不知道 my_seq 的长度，但是我们想生成一个从1到N的整数数列，N代表的是向量 my_seq 的长度。 换句话说，我们想创建一个新的向量 (1,2,3,···)，它的长度与 my_seq 相同。 有几种方法可以实现。一种方式是结合 : 运算符和 length() 函数，就像 1:length(my_seq) 这样，我们试一下： > 1:length(my_seq) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 另一种方式是使用 seq(along.with = my_seq) 函数： > seq(1, along.with = my_seq) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 不管怎么样，与许多常见任务一样，R 有一个独立的能提供此功能的内置函数，称为 seq_along(), 我们试一下： > seq_along(my_seq) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 在 R 语言中，还有几种方式可以解决这个问题。当你成为高级的R语言程序员，你可以设计你自己的函数来解决那些没有更好选择时的问题。在将来的课程中，我们将探索如何编写你自己的函数。 另一个与创建数列相关的函数是 rep(), 其含义是 replicate, 下面来看一下它的一些用法。 如果我们想要创建一个包含 40个零的向量，可以使用 rep(0, times = 40): > rep(0, times = 40) [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 [39] 0 0 如果想创建一个重复 10次 (0, 1, 2)的向量，可以执行 rep(c(0, 1, 2), times = 10). > rep(c(0, 1, 2), times = 10) [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 如果想创建一个重复10次0，然后重复10次1，最后再重复10次2的向量，可以使用 each 参数，试一下 rep(c(0, 1, 2), each = 10): > rep(c(0, 1, 2), each = 10) [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-10 22:36:05 "},"R/RProgramming/lesson4.html":{"url":"R/RProgramming/lesson4.html","title":"向量","keywords":"","body":"Lesson 4: 向量 R 语言中最简单以及最常用的数据结构是向量。 向量有两类：原子向量 和 列表。原子向量仅包含一种数据类型，而列表可以包含多种数据类型。 在之前的课程中，我们处理的都是是数字向量，这是原子向量的一种类型。其他的原子向量类型包括逻辑向量，整数向量，双向量和字符向量。整数和双向量统称为数字向量。本课程中，我们来学习下逻辑向量和字符向量。 逻辑向量 逻辑向量包含的值是 TRUE, FALSE 和 NA (意思是 not availabel)。这些值由逻辑 条件 的结果生成。我们来试一些简单的条件。 首先，创建一个名为 num_vect 的数字向量，包含(0.5, 55, -10, 6). > num_vect 现在，创建一个称为 tf 的变量，得到 num_vect 的结果。 > tf 你认为 tf 的结果是什么样的呢？是一个逻辑值，还是一个包含 4 个逻辑值的向量呢？我们看一下结果： > tf [1] TRUE FALSE TRUE FALSE num_vect 是个判断条件，tf 会判断每个元素是否符合判断条件，然后返回每个元素的逻辑值。 我们来尝试另一个判断条件： > num_vect >= 6 [1] FALSE TRUE FALSE TRUE 上述例子中的 和 >= 符号称为逻辑运算符，其他的逻辑运算符有：>, , ==(等于) 和 !=(不等于). 如果有两个逻辑表达式呢，比如 A | B 表示 A 或 B 至少一个为 TRUE 的判断结果，A & B 表示 A 和 B 都是 TRUE 的判断结果。比如下面这些例子： | (3 > 5) & (4 == 4) 1: FALSE 2: TRUE Selection: 1 | Your dedication is inspiring! | (TRUE == TRUE) | (TRUE == FALSE) 1: TRUE 2: FALSE Selection: 1 | Nice work! | ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5) 1: TRUE 2: FALSE Selection: 1 | Your dedication is inspiring! 字符向量 字符向量也在 R 语言中十分普遍。区分字符串可使用双引号(\"\")。 创建一个名为 my_char 的字符串向量，使其包含下列单词：\"My\", \"name\", \"is\". > my_char my_char [1] \"My\" \"name\" \"is\" my_char 是一个长度为 3 的字符向量，如果想将字符向量转换成一个字符串（可以看成是一个元素数为 1 的向量），可以使用 paste() 函数： > paste(my_char, collapse = \" \") [1] \"My name is\" collapse 参数是告诉 R，我们想用 单空格 分隔开 my_char 中的元素。 使用 c() 函数在 my_char 后面添加内容： > my_name my_name [1] \"My\" \"name\" \"is\" \"Daddy\" 再次使用 paste() 函数，将 my_name 转换成一个单独的字符串，不要忘了加上 collapse = \" \"! > paste(my_name, collapse = \" \") [1] \"My name is Daddy\" 在一些简单的例子中，可以使用 paste() 做两个长度为 1 的字符串的加法，例如 paste(\"Hello\", \"world!\", sep = \" \")，sep 参数的意思是用空格分隔开两个加入的元素。 > paste(\"Hello\", \"world!\", sep = \" \") [1] \"Hello world!\" 下面我们将一个整数向量与字符串向量相加： > paste(1:3, c(\"X\", \"Y\", \"Z\"), sep = \"\") [1] \"1X\" \"2Y\" \"3Z\" 如果两个相加的向量长度不同该如何？（我们之前谈论过，向量回收机制（再循环机制？如何翻译？） > paste(LETTERS, 1:4, sep = \"-\") [1] \"A-1\" \"B-2\" \"C-3\" \"D-4\" \"E-1\" \"F-2\" \"G-3\" \"H-4\" \"I-1\" \"J-2\" \"K-3\" \"L-4\" [13] \"M-1\" \"N-2\" \"O-3\" \"P-4\" \"Q-1\" \"R-2\" \"S-3\" \"T-4\" \"U-1\" \"V-2\" \"W-3\" \"X-4\" [25] \"Y-1\" \"Z-2\" LETTERS 是 R 预定义的变量，是包含了全部 26 个英语字母的字符串向量。 因为字符向量 LETTERS 长于数字向量 1:4，所以 R 简单的循环，重复，直到 1：4 匹配到 LETTERS 的长度。 不值一提的是，数字向量 1:4 可以使用 paste() 函数 强制融合 进字符向量。我们会在其他课程中探讨 强制融合 的机制，但是它的真实含义是数字 1，2，3 和 4，在输出的结果中对 R 来说，不再是数字，而是字符串 \"1\", \"2\", \"3\" 和 \"4\". Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-11 11:32:29 "},"R/RProgramming/lesson5.html":{"url":"R/RProgramming/lesson5.html","title":"缺失值","keywords":"","body":"Lesson 5: 缺失值 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-11 11:32:29 "}}