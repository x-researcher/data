{"./":{"url":"./","title":"Introduction","keywords":"","body":"数据科学, 学习手册 记录数据科学学习时的资料，好记性不如烂笔头，及时归纳总结，也方便查询。 数据科学的主要语言为 R 和 Python，一直非常喜欢 Python，但没有系统性的学习，将来补上这方面知识，而为了目前的科研数据分析，先学习 R 语言。 目前正在学习的课程： [ ] R Programming Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-11 11:53:56 "},"R/RProgramming/":{"url":"R/RProgramming/","title":"R Programming","keywords":"","body":"使用 swirl 学习 R 语言 启动 R R 安装 swirl > install.packages(\"swirl\") 调用、安装课程并启动 swirl > library(\"swirl\") > install_course(\"Course Name Here\") # 课程列表参考 https://github.com/swirldev/swirl_courses > swirl() 后面就是按照提醒一步步操作，先给自己起个名字，然后选择课程。我选择的是 R Programming，最后选择课时。 swirl 的其他命令 可输入 info() 查看 > info() | When you are at the R prompt (>): | -- Typing skip() allows you to skip the current question. | -- Typing play() lets you experiment with R on your own; swirl will ignore | what you do... | -- UNTIL you type nxt() which will regain swirl's attention. | -- Typing bye() causes swirl to exit. Your progress will be saved. | -- Typing main() returns you to swirl's main menu. | -- Typing info() displays these options again. R Programming 课程目录 [x] 1. Basic Building Blocks [x] 2. Workspace and Files [x] 3. Sequences of Numbers [x] 4. Vectors [x] 5. Missing Values [ ] 6. Subsetting Vectors [ ] 7. Matrices and Data Frames [ ] 8. Logic [ ] 9. Functions [ ] 10. lapply and sapply [ ] 11. vapply and tapply [ ] 12. Looking at Data [ ] 13. Simulation [ ] 14. Dates and Times [ ] 15. Base Graphics Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-12 17:27:53 "},"R/RProgramming/lesson1.html":{"url":"R/RProgramming/lesson1.html","title":"基本构件","keywords":"","body":"Lesson 1: 基本构件 本课时，我们将探索一些 R 语言的基本构件。 如需帮助，可以使用 help.start()。 最简单的形式，R 语言可用作交互式计算器： > 5 + 7 [1] 12 我们可以创建一个变量来储存计算结果，而不用每次都重新输入 5 + 7 ，在 R 语言中，给变量赋值使用的符号是 （小于号后面跟一个减号）。 可以把这个分配运算符看作一个箭头，把箭头右侧的值赋给左侧的变量，例如： > x 你可能注意到了，R 并没有直接输出计算结果 12，当你使用分配运算符时，R 假设你不想立即看到计算结果，而是倾向于之后要使用此计算值。如果想查看变量 x 的内容，直接输入 x，然后按 Enter， > x [1] 12 下面创建一个新变量 y ，使 y = x - 3 > y y [1] 9 使用 y 或 y ，完全取决与你的个人习惯，但是在每个分配运算符两侧各留一个 空格 是个很好的习惯。 现在，让我们创建一个称为 向量 的小的数字集合。 在 R 语言中，任何包含数据的东西都称为一个数据结构，而数值向量是最简单的数据结构类型。 最简单的创建一个向量的方式是使用 c() 函数, 它代表的意思是 concatenate 或 combine。下面创建一个包含数字 1.1，9 和 3.14 的向量 z： > z z [1] 1.10 9.00 3.14 如果对某个特定函数存在疑问，可以使用 \"?\" 命令访问 R 自带的帮助文件，例如，如果想得到 c() 函数更多的信息，可以输入 ?c 查看（不用输入括号）。 > ?c c package:base R Documentation Combine Values into a Vector or List Description: This is a generic function which combines its arguments. The default method combines its arguments to form a vector. All arguments are coerced to a common type which is the type of the returned value, and all attributes except names are removed. Usage: ... 下面我们创建一个包含 z 和 555 的新向量。 > c(z, 555) [1] 1.10 9.00 3.14 555.00 再创建一个向量 c(z, 555, z) > c(z, 555, z) [1] 1.10 9.00 3.14 555.00 1.10 9.00 3.14 数值向量能被用于算术运算。例如： > z * 2 + 100 [1] 102.20 118.00 106.28 首先是每个元素乘以 2，然后每个元素的计算结果再加上 100. 其他常见的数学运算符有 \"+\", \"-\", \"/\", 和 \"^\"(squared 平方)。使用函数 sqrt() 得到平方根，以及使用 abs() 函数得到绝对值。 创建一个新函数 my_sqrt, 求 z-1 的平方根： > my_sqrt my_sqrt [1] 0.3162278 2.8284271 1.4628739 R 首先会将向量 z 的每个元素减去 1，然后是每个结果独立开平方根，得到的是和向量 z 长度一样的新的向量。 创建一个新的向量 my_div，使其等于 向量 z 除于 my_sqrt: > my_div my_div [1] 3.478505 3.181981 2.146460 在之前的例子中，当我们计算 z * 2 + 100 时，z 是一个长度为 3 的向量，但是技术上说， 2 和 100 是长度为 1 的向量。其背后的含义是，R 再循环 制造了一个向量 2s 和一个向量 100s，换句话说，当你要求 R 计算 z 2 + 100 时，它真实计算的是：z c(2, 2, 2) + c(100, 100, 100). 为了了解 在循环 机制时如何运作的，我们看另一个例子，试着做一个运算，c(1, 2, 3, 4) + c(0, 10) > c(1, 2, 3, 4) + c(0, 10) [1] 1 12 3 14 如果长向量的长度 不是 短向量的倍数，R 仍会应用 在循环 机制，但是会弹出一个警告，让你知道有些怪怪的事情正在运行。例如，我们尝试运行 c(1, 2, 3, 4) + c(0, 10, 100) > c(1, 2, 3, 4) + c(0, 10, 100) [1] 1 12 103 4 Warning message: In c(1, 2, 3, 4) + c(0, 10, 100) : longer object length is not a multiple of shorter object length Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-10 22:36:05 "},"R/RProgramming/lesson2.html":{"url":"R/RProgramming/lesson2.html","title":"工作空间和文件","keywords":"","body":"Lesson 2: 工作空间和文件 在本节课，你将能学到，在 R 语言中如何检查你的当地工作空间，以及开始探索工作空间与机器的文件系统之间的关系。 因为不同操作系统在处理事情比如文件路径等有不同的规定，这些命令的输出结果也可能因机器而异。不管怎么说，重要的是，R 语言为与文件交互提供了一个通用 API. getwd() 获取本 R 课程当前运行的目录： > getwd() [1] \"/root\" ls() 列出您当前工作空间的所有项目： > ls() [1] \"my\" \"my_div\" \"my_sqrt\" \"mydiv\" \"x\" \"y\" \"z\" 对 x 赋值 9 > x ls() [1] \"my\" \"my_div\" \"my_sqrt\" \"mydiv\" \"x\" \"y\" \"z\" list.files() 或 dir() 列出在本工作目录下的所有文件： > list.files() [1] \"1\" \"anaconda3\" [3] \"gitback.sh\" \"gitback.sh.save\" [5] \"install.sh\" \"JupyterLab\" 使用 ?list.files 查看更多信息 args() 查看函数可以采用什么样的参数。 例如，查看 list.files() 函数可以使用什么参数： > args(list.files) function (path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) NULL 将当前工作目录赋值给变量 old.dir: > old.dir 我们可以在课程结束时用此变量返回到我们开始的地方。许多像 getwd() 这样的询问函数有个非常有用特性，可以返回问题的答案为一个函数的结果。 dir.create() 在当前工作目录下创建一个名为 testdir 的目录。 > dir.create(\"testdir\") setwd() 设置当前目录为 testdir > setwd(\"testdir\") 通常，你想设置你的工作目录为某些敏感的地方，也许需要创建你正在运行的特有项目。事实上，组织你的 R 包方面的工作，使用 RStudio 是个明智的选择。下载 Rstudio 在 http://www.rstudio.com/ file 系类函数 file.create() 在当前工作目录下创建一个名为 mytest.R 的文件： > file.create('mytest.R') [1] TRUE # 这个文件就时该工作目录下的唯一的文件，查看一下： > list.files() [1] \"mytest.R\" file.exists() 检查当前工作目录下是否存在 mytest.R 文件： > file.exists(\"mytest.R\") [1] TRUE file.info() 查看文件 mytest.R 的信息： > file.info(\"mytest.R\") size isdir mode mtime ctime mytest.R 0 FALSE 644 2020-03-09 22:49:36 2020-03-09 22:49:36 atime uid gid uname grname mytest.R 2020-03-09 22:49:36 0 0 root root 可以使用 $ 运算符，比如 file.info('mytest.R')$mode --- 获得特定的项目 file.rename() 重命名 mytest.R 为 mytest2.R > file.rename('mytest.R','mytest2.R') [1] TRUE file.copy() 备份 mytest2.R 为 mytest3.R: > file.copy('mytest2.R','mytest3.R') [1] TRUE file.remove() 移除文件 file.path() 提供某文件的相对路径： > file.path('mytest3.R') [1] \"mytest3.R\" 可以利用这个特性获得文件夹的相对路径，例如： > file.path(\"folder1\", \"folder2\") [1] \"folder1/folder2\" dir.create() ?dir.create 查看帮助文件，注意 recursive 参数，为了创建嵌套目录，recursive 应设为 TRUE. > ?dir.create files2 package:base R Documentation Manipulation of Directories and File Permissions Description: These functions provide a low-level interface to the computer's file system. Usage: dir.exists(paths) dir.create(path, showWarnings = TRUE, recursive = FALSE, mode = \"0777\") Sys.chmod(paths, mode = \"0777\", use_umask = TRUE) Sys.umask(mode = NA) Arguments: path: a character vector containing a single path name. Tilde expansion (see ‘path.expand’) is done. paths: character vectors containing file or directory paths. Tilde expansion (see ‘path.expand’) is done. showWarnings: logical; should the warnings on failure be shown? recursive: logical. Should elements of the path other than the last be created? If true, like the Unix command ‘mkdir -p’. mode: the mode to be used on Unix-alikes: it will be coerced by ‘as.octmode’. For ‘Sys.chmod’ it is recycled along ‘paths’. use_umask: logical: should the mode be restricted by the ‘umask’ setting? Details: ··· 在当前工作目录下，创建一个名为 testdir2 的文件夹，以及一个名为 testdir3 的子文件夹（这利用到之前提到的 file.path() 的特性）。 > dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE) 使用 setwd() 函数返回原来的工作目录（可重新调用之前创建的变量 old.dir） > setwd(old.dir) 这对于保存之前的设置，开始一个分析，然后在结束时返回起始位置十分有帮助。 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-10 22:36:05 "},"R/RProgramming/lesson3.html":{"url":"R/RProgramming/lesson3.html","title":"数列","keywords":"","body":"Lesson 3: 数列 这节课，学习在 R 中如何创建数列。 在 R 中，最简单的创建数列的方式是使用 : 运算符，输入 1：20 查看它是如何运作的： > 1:20 [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 它的输出值为 1-20 的所有整数。 我们也能用它创建实数数列。例如： > pi:10 [1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593 结果是从 pi 开始，递增间隔为 1 的实数向量。上限 10 是不可能达到的，因为它的下一个数据大于 10. 如果输入 15:1 会发生什么？ 试一下： > 15:1 [1] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 返回的结果为一组递减数列。 学习 R 时，有任何不清楚的函数功能，都可以通过查询 R 自带的帮助文档获得，此处查看一下':'运算符的详细信息： > ?':' The binary operator ‘:’ has two meanings: for factors ‘a:b’ is equivalent to ‘interaction(a, b)’ (but the levels are ordered and labelled differently). For other arguments ‘from:to’ is equivalent to ‘seq(from, to)’, and generates a sequence from ‘from’ to ‘to’ in steps of ‘1’ or ‘-1’. Value ‘to’ will be included if it differs from ‘from’ by an integer up to a numeric fuzz of about ‘1e-7’. Non-numeric arguments are coerced internally (hence without dispatching methods) to numeric-complex values will have their imaginary parts discarded with a warning. Value: For numeric arguments, a numeric vector. This will be of type ‘integer’ if ‘from’ is integer-valued and the result is representable in the R integer type, otherwise of type ‘\"double\"’ (aka ‘mode’ ‘\"numeric\"’). For factors, an unordered factor with levels labelled as ‘la:lb’ and ordered lexicographically (that is, ‘lb’ varies fastest). References: ··· Examples: 1:4 pi:6 # real 6:pi # integer f1 通常情况下，在创建数列时，我们想获得比 ':' 运算符提供的更多的自由度， seq() 函数可以满足我们的目的。 seq() 函数最基本的用法和 : 运算符一样，例如 seq(1, 10): > seq(1, 20) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 结果与 1:20 一致。如果要创建一个增幅为 0.5，范围在 0-10 的数列，可以使用 seq(0, 10, by=0.5) > seq(0, 10, by = 0.5) [1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 [16] 7.5 8.0 8.5 9.0 9.5 10.0 如果我们不关心增幅，只是想获得5-10范围内的30个数字，seq(5 ,10, length=30) 可以达到这个目的。尝试一下，并将结果赋值给变量 my_seq > my_seq 为了确认 my_seq 变量的长度为 30，可以使用 length() 函数。 > length(my_seq) [1] 30 假设我们不知道 my_seq 的长度，但是我们想生成一个从1到N的整数数列，N代表的是向量 my_seq 的长度。 换句话说，我们想创建一个新的向量 (1,2,3,···)，它的长度与 my_seq 相同。 有几种方法可以实现。一种方式是结合 : 运算符和 length() 函数，就像 1:length(my_seq) 这样，我们试一下： > 1:length(my_seq) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 另一种方式是使用 seq(along.with = my_seq) 函数： > seq(1, along.with = my_seq) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 不管怎么样，与许多常见任务一样，R 有一个独立的能提供此功能的内置函数，称为 seq_along(), 我们试一下： > seq_along(my_seq) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 在 R 语言中，还有几种方式可以解决这个问题。当你成为高级的R语言程序员，你可以设计你自己的函数来解决那些没有更好选择时的问题。在将来的课程中，我们将探索如何编写你自己的函数。 另一个与创建数列相关的函数是 rep(), 其含义是 replicate, 下面来看一下它的一些用法。 如果我们想要创建一个包含 40个零的向量，可以使用 rep(0, times = 40): > rep(0, times = 40) [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 [39] 0 0 如果想创建一个重复 10次 (0, 1, 2)的向量，可以执行 rep(c(0, 1, 2), times = 10). > rep(c(0, 1, 2), times = 10) [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 如果想创建一个重复10次0，然后重复10次1，最后再重复10次2的向量，可以使用 each 参数，试一下 rep(c(0, 1, 2), each = 10): > rep(c(0, 1, 2), each = 10) [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-10 22:36:05 "},"R/RProgramming/lesson4.html":{"url":"R/RProgramming/lesson4.html","title":"向量","keywords":"","body":"Lesson 4: 向量 R 语言中最简单以及最常用的数据结构是向量。 向量有两类：原子向量 和 列表。原子向量仅包含一种数据类型，而列表可以包含多种数据类型。 在之前的课程中，我们处理的都是是数字向量，这是原子向量的一种类型。其他的原子向量类型包括逻辑向量，整数向量，双向量和字符向量。整数和双向量统称为数字向量。本课程中，我们来学习下逻辑向量和字符向量。 逻辑向量 逻辑向量包含的值是 TRUE, FALSE 和 NA (意思是 not availabel)。这些值由逻辑 条件 的结果生成。我们来试一些简单的条件。 首先，创建一个名为 num_vect 的数字向量，包含(0.5, 55, -10, 6). > num_vect 现在，创建一个称为 tf 的变量，得到 num_vect 的结果。 > tf 你认为 tf 的结果是什么样的呢？是一个逻辑值，还是一个包含 4 个逻辑值的向量呢？我们看一下结果： > tf [1] TRUE FALSE TRUE FALSE num_vect 是个判断条件，tf 会判断每个元素是否符合判断条件，然后返回每个元素的逻辑值。 我们来尝试另一个判断条件： > num_vect >= 6 [1] FALSE TRUE FALSE TRUE 上述例子中的 和 >= 符号称为逻辑运算符，其他的逻辑运算符有：>, , ==(等于) 和 !=(不等于). 如果有两个逻辑表达式呢，比如 A | B 表示 A 或 B 至少一个为 TRUE 的判断结果，A & B 表示 A 和 B 都是 TRUE 的判断结果。比如下面这些例子： | (3 > 5) & (4 == 4) 1: FALSE 2: TRUE Selection: 1 | Your dedication is inspiring! | (TRUE == TRUE) | (TRUE == FALSE) 1: TRUE 2: FALSE Selection: 1 | Nice work! | ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5) 1: TRUE 2: FALSE Selection: 1 | Your dedication is inspiring! 字符向量 字符向量也在 R 语言中十分普遍。区分字符串可使用双引号(\"\")。 创建一个名为 my_char 的字符串向量，使其包含下列单词：\"My\", \"name\", \"is\". > my_char my_char [1] \"My\" \"name\" \"is\" my_char 是一个长度为 3 的字符向量，如果想将字符向量转换成一个字符串（可以看成是一个元素数为 1 的向量），可以使用 paste() 函数： > paste(my_char, collapse = \" \") [1] \"My name is\" collapse 参数是告诉 R，我们想用 单空格 分隔开 my_char 中的元素。 使用 c() 函数在 my_char 后面添加内容： > my_name my_name [1] \"My\" \"name\" \"is\" \"Daddy\" 再次使用 paste() 函数，将 my_name 转换成一个单独的字符串，不要忘了加上 collapse = \" \"! > paste(my_name, collapse = \" \") [1] \"My name is Daddy\" 在一些简单的例子中，可以使用 paste() 做两个长度为 1 的字符串的加法，例如 paste(\"Hello\", \"world!\", sep = \" \")，sep 参数的意思是用空格分隔开两个加入的元素。 > paste(\"Hello\", \"world!\", sep = \" \") [1] \"Hello world!\" 下面我们将一个整数向量与字符串向量相加： > paste(1:3, c(\"X\", \"Y\", \"Z\"), sep = \"\") [1] \"1X\" \"2Y\" \"3Z\" 如果两个相加的向量长度不同该如何？（我们之前谈论过，向量回收机制（再循环机制？如何翻译？） > paste(LETTERS, 1:4, sep = \"-\") [1] \"A-1\" \"B-2\" \"C-3\" \"D-4\" \"E-1\" \"F-2\" \"G-3\" \"H-4\" \"I-1\" \"J-2\" \"K-3\" \"L-4\" [13] \"M-1\" \"N-2\" \"O-3\" \"P-4\" \"Q-1\" \"R-2\" \"S-3\" \"T-4\" \"U-1\" \"V-2\" \"W-3\" \"X-4\" [25] \"Y-1\" \"Z-2\" LETTERS 是 R 预定义的变量，是包含了全部 26 个英语字母的字符串向量。 因为字符向量 LETTERS 长于数字向量 1:4，所以 R 简单的循环，重复，直到 1：4 匹配到 LETTERS 的长度。 不值一提的是，数字向量 1:4 可以使用 paste() 函数 强制融合 进字符向量。我们会在其他课程中探讨 强制融合 的机制，但是它的真实含义是数字 1，2，3 和 4，在输出的结果中对 R 来说，不再是数字，而是字符串 \"1\", \"2\", \"3\" 和 \"4\". Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-11 11:32:29 "},"R/RProgramming/lesson5.html":{"url":"R/RProgramming/lesson5.html","title":"缺失值","keywords":"","body":"Lesson 5: 缺失值 缺失值在统计和数据分析中发挥着重要的作用。通常情况下，缺失值不能被忽略，而且应该被仔细研究来判断是否存在潜在的模式或原因导致了缺失值的形成。 NA 在 R 语言中，NA 代表的意思是不可用(not availabel) 或 缺失(missing，在统计学意义上)，本课程，我们将进一步探讨缺失值。 任何涉及 NA 的操作通常都会生成 NA。为了说明，我们创建一个向量 c(44, NA, 5, NA)，并将其值赋予变量 x。 > x x * 3 [1] 132 NA 15 NA 注意，向量 x 中的 NA 值元素，在结果向量中仍是 NA。 为了让事情更加有趣，我们创建一个向量 y，使其包含 1000 个符合标准正态分布的值。 > y 然后，创建一个包含 1000 个 NA 的向量 z： > z 最后，从这 2000 个值(y 和 z)中随机选择 100 个，我们不清楚这些值中包含了多少个 NA 值： > my_data 首先，我们想知道 NA 位于 my_data 的位置，is.na()函数会告诉我们向量的每一个元素是否是 NA： my_na my_na [1] FALSE TRUE TRUE FALSE TRUE FALSE TRUE FALSE FALSE TRUE TRUE FALSE [13] FALSE FALSE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE [25] TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE TRUE FALSE TRUE FALSE [37] TRUE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE TRUE TRUE TRUE [49] FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE TRUE TRUE FALSE [61] TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE TRUE FALSE TRUE TRUE [73] FALSE TRUE TRUE FALSE TRUE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [85] FALSE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE TRUE [97] FALSE TRUE FALSE TRUE 每一个 TRUE，表示的即是 NA，而每一个 FALSE，表示这个值是来自标准正态分布的随机值。 在之前的逻辑运算符的讨论中，我们介绍了 == 运算符，可以测试两个项目是否相等。因此，我们认为 my_data == NA 也能生成和 is.na() 一样的运算符。来试一下： > my_data == NA [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA 我们得到的结果却是一个全是 NA 的向量，这是因为，确切的说 NA 不是一个具体的值，它仅是一个不可用的数据的占位符，因此这个逻辑表达式是不完整的，R 只能返回一个和 my_data 长度一致，全是 NA 的向量。 不用担心是否这点让人困惑。关键是任何时候使用逻辑表达式时都要谨慎，因为单个 NA 可能会破环掉整个过程。 回到手头的任务，现在我们有了一个向量 my_na，它包含了每个元素是否是 NA 的逻辑值，我们也能计算出数据中有多少个 NA。 诀窍是认识到在表面之下，R 表示数字 1 为真，数字 0 为假。因此，如果我们取一堆真值和假值的和，我们就得到真值的总数。 我们来试一试，在 my_na 上调用 sum() 函数来计算其真值的数量，也就是 my_data 中 NA 的数量。 > sum(my_na) [1] 56 最后，让我们来看看数据，一切都“合起来”。将 my_data 输出到控制台： > my_data [1] -0.28801435 NA NA 0.36748726 NA -1.19633286 [7] NA 0.66454307 -1.00578082 NA NA 1.81471621 [13] 2.17424903 -1.71439226 NA -0.24878883 NA NA [19] NA NA NA NA -1.02406254 NA [25] NA -1.15460010 -0.39492211 0.26074351 NA NA [31] NA -2.90531031 NA -2.33724788 NA -1.13759834 [37] NA 0.26175013 -1.52020692 NA NA NA [43] -2.23693352 0.92138647 -1.46456656 NA NA NA [49] 1.36848127 -0.41126305 -1.05480267 NA NA NA [55] NA -0.32308052 0.37748786 NA NA 0.52518884 [61] NA NA -0.24748836 NA -1.42900373 NA [67] NA NA NA -0.72784037 NA NA [73] -0.39686325 NA NA -2.35212605 NA NA [79] -0.02377080 NA -0.00310782 NA 1.41064101 NA [85] -0.50119562 NA NA 1.95195002 0.29982655 -1.01580805 [91] -0.65818903 NA NA 2.24820040 -0.31970510 NA [97] -1.09487594 NA -0.16355008 NA NaN 现在我们已经了解了 NA，让我来看缺失值的第二种类型：NaN，它代表的是非数字(not a number)。要生成 NaN，现在试一下 0 除于 0(正斜杠)： > 0/0 [1] NaN 我们再做一次，只是为了好玩。在 R 中，Inf 代表的是无穷，如果 Inf 减去 Inf 会发生什么？ > Inf - Inf [1] NaN Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-12 17:27:53 "},"R/RProgramming/lesson6.html":{"url":"R/RProgramming/lesson6.html","title":"子集向量","keywords":"","body":"Lesson 6: 子集向量 在这节课中，我们将看到如何根据我们指定的一些条件从向量中提取元素。 例如，我们也许只对一个向量的前 20 个元素感兴趣，活着仅对那些不是 NA 的元素感兴趣，或者只对那些是正的或者对应于一个特定的感兴趣的元素感兴趣。本课结束时，你将了解如何处理这些场景。 我们已经创建了一个向量 x，它包含了从标准正态分布中随机选取的 20 个数字，以及 20 个 NA。现在输入 x，看它是否是这样的： > x [1] NA NA -0.01301518 NA NA NA [7] -0.47721718 NA 0.23556194 NA NA NA [13] -0.56827616 NA -1.39451656 0.20122132 0.09755386 2.47619742 [19] -0.08464506 0.80707804 -0.28220555 -0.85445817 1.65740981 NA [25] NA 0.19560065 NA NA -0.84176773 0.30555518 [31] NA 0.27902072 NA NA 0.91157021 NA [37] NA -0.70343162 NA -0.64953318 你告诉 R 你想从向量中选择一部分元素(比如：一个子集)的方法是在向量的名字后面的方括号中放置一个“索引向量”。 比如一个简单的例子，试一下 x[1:10] 来查看向量 x 的前 10 个元素。 > x [1:10] [1] NA NA -0.01301518 NA NA NA [7] -0.47721718 NA 0.23556194 NA 索引向量有四种不同的形式：逻辑向量，正整数的向量，负整数的向量，字符串的向量。每一个我们在这节课都会讲到。 逻辑向量 让我们从逻辑向量建立索引开始。在处理真实数据时，一个常见的场景时我们想要提取一个向量中不是 NA 的所有元素。回想一下，is.na(x) 生成了一个长度于 x 相同的逻辑值向量，其 TRUE 对应于 x 中的 NA，FALSE 对应于 x 中的非 NA 值。 考虑一下，x[is.na(x)] 会返回什么结果： > x [is.na(x)] [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA 提取的是所有的 NA 值。 回想一下，! 给我们一个逻辑表达式的否定式，所有 !is.na(x) 可以被解读为 is not NA。因此，我们想要创建一个包含所有来自 x 的非 NA 值的向量 y，我们可以使用 y , 试试吧： > y y [1] 1.58802569 -1.01293755 0.37155713 1.69750561 -1.60847397 0.60249903 [7] -0.41862256 -0.48870077 1.18646771 -0.54252969 -0.97333657 1.13544799 [13] 0.06677423 0.56186192 0.16981586 -1.26339820 -0.78870739 -0.41639811 [19] -0.17735571 -2.33724788 现在我们已经隔离了 x 的非缺失值，并将它们放入 y 中，子集 y 就是我们想要的。 回想一下，表达式 y > 0 将给我们一个逻辑值向量，它的长度与 y 相同，TRUE 对应于大于 0 的 y 的值，FALSE 对应于小于等于 0 的 y 的值。你认为 y[y > 0] 会返回什么？试一下： > y [y > 0] [1] 1.58802569 0.37155713 1.69750561 0.60249903 1.18646771 1.13544799 0.06677423 [8] 0.56186192 0.16981586 你也许想知道为什么我们一开始不用 x[x > 0] 来提取 x 中的正值元素，试一下看下结果： > x [x > 0] [1] NA NA NA 1.58802569 NA NA [7] 0.37155713 NA 1.69750561 NA 0.60249903 NA [13] NA NA 1.18646771 NA NA 1.13544799 [19] NA 0.06677423 NA NA 0.56186192 0.16981586 [25] NA NA NA NA NA 因为 NA 不是一个值，而是一个未知数的占位符，所以表达式 NA > 0 的结果为 NA。因此，当我们这样做的时候，我们得到了一堆和我们的正数混合在一起的 NA。 结合逻辑运算和子集的知识，我可以这样做，x[!is.na(x) & x > 0]，试一下： > x [! is.na(x) & x > 0] [1] 1.58802569 0.37155713 1.69750561 0.60249903 1.18646771 1.13544799 0.06677423 [8] 0.56186192 0.16981586 在本例中，我们只请求了非缺失值且大于零的 x 值。 我已经向您展示了如何使用 x[1:10] 来子集化 x 的前十个值。在本例中，我们在方括号内提供了一个正整数向量，它告诉 R 只返回编号为 1 到 10 的 x 的元素。 许多编程语言使用所谓的“从零开始的索引”，这意味着向量的第一个元素被认为是元素 0。R 使用“基于 1 的索引”，这意味着一个向量的第一个元素被认为是元素 1。 您能指出我们如何将 x 的第 3、5 和 7 个元素子集化吗? 提示：使用 c() 函数将元素编号指定为数字向量。 > x [c(3, 5, 7)] [1] 1.969917 NA NA 重要的是，当使用整数向量来子集化向量 x 时，我们坚持使用索引集 {1, 2, ..., 40}, 因为 x 只有 40 个元素。如果我们提取 x 的第 0 个元素（即 x [0] ），试一下会发生什么。 > x [0] numeric(0) 正如你所料，我们没有得到任何有用的东西。不行的是，R 并灭有阻止我们这样做。如果我们提取 x 的第 3000 个元素呢，试一下。 > x [3000] [1] NA 同样，没什么有用的，但 R 不阻止我们提出要求。这是个警示。你应该确保你所提取的是在你所处理向量的范围内。 如果我们对 x 除了第 2 个和第 10 个元素以外的所有元素感兴趣呢？如果列出所有的数字索引将是很乏味的。 幸运的是，R 接受负整数索引。x[c(2, 10)] 只给出了 x 的第 2 和第 10 个元素，而 x[c(-2, -10)] 给出了除第 2 和第 10 个以外的所有 x 的元素。输入 x[c(-2, -10)] 来看看。 > x [c(-2, -10)] [1] NA 1.96991716 -0.00232278 NA NA NA [7] NA NA NA -0.11091275 0.10989098 NA [13] 0.27947713 -0.57222361 NA 0.65100583 0.41413828 -0.64963226 [19] -0.15977023 NA NA NA 1.53372448 -0.47685392 [25] NA -0.25140323 1.40447082 NA 1.47180257 NA [31] NA 1.47247464 NA -0.08781325 0.78578649 NA [37] NA 1.90042642 指定多个负数的一种简便方法是将负数放在正数向量的前面。输入 x[-c(2, 10)] 来得到完全相同的结果。 > x [-c(2, 10)] [1] NA 1.96991716 -0.00232278 NA NA NA [7] NA NA NA -0.11091275 0.10989098 NA [13] 0.27947713 -0.57222361 NA 0.65100583 0.41413828 -0.64963226 [19] -0.15977023 NA NA NA 1.53372448 -0.47685392 [25] NA -0.25140323 1.40447082 NA 1.47180257 NA [31] NA 1.47247464 NA -0.08781325 0.78578649 NA [37] NA 1.90042642 到目前为止，我们已经介绍了三种类型的索引向量，逻辑型，正整数型和负整数型。剩下的唯一类型要求我们引入“命名”元素的概念。 创建一个包含三个命名元素的数字向量 vect ← c(foo = 11, bar = 2, norf = NA). > vect 当我们将 vect 打印到控制台时，你将看到每个元素都有一个名称。试一下。 > vect foo bar norf 11 2 NA 我们还可以通过将 vect 作为参数传递给 names() 函数来获得 vect 的名称。试试吧。 > names(vect) [1] \"foo\" \"bar\" \"norf\" 活着，我们可以用 c(11, 2, NA) 创建一个未命名的向量 vect2. 现在试一下。 > c(11, 2, NA) [1] 11 2 NA 创建一个名为 vect2 的普通（未命名）向量，其中包含 c(11, 2, NA). > vect2 然后，我们可以使用 names(vect2) 将 names 属性添加到 vect2 中。去做吧。 > names(vect2) 现在，让我们利用 identical() 函数来检查 vect 和 vect2 是否相同。 > identical(vect, vect2) [1] TRUE 事实上，vect 和 vect2 是相同的命名向量。 现在，回到通过命名元素设置向量子集的问题上。你认为下面哪一个会提取出 vect 的第二个元素？ 1: vect [bar] 2: vect [\"2\"] 3: vect [\"bar\"] 答案是第三个，试一下。 > vect [\"bar\"] bar 2 同样，我们可以用 vect[c(\"foo\", \"bar\")] 来指定一个名称向量。试一下。 > vect [c(\"foo\", \"bar\")] foo bar 11 2 现在你已经了解了从向量中设置数据子集的四种方法。不同的方法在不同的情况下是最好的，如有疑问，尝试一下！ Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-18 19:17:29 "}}