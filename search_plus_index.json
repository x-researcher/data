{"./":{"url":"./","title":"Introduction","keywords":"","body":"数据科学, 学习手册 记录数据科学学习时的资料，好记性不如烂笔头，及时归纳总结，也方便查询。 数据科学的主要语言为 R 和 Python，一直非常喜欢 Python，但没有系统性的学习，将来补上这方面知识，而为了目前的科研数据分析，先学习 R 语言。 DONE： [x] R Programming TO-DO: [ ] Regression Models [ ] Getting and Cleaning Data [ ] Statistical Inference [ ] Advanced R Programming Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 15:56:20 "},"R/RProgramming/":{"url":"R/RProgramming/","title":"R 语言基础","keywords":"","body":"使用 swirl 学习 R 语言 启动 R R 安装 swirl > install.packages(\"swirl\") 调用、安装课程并启动 swirl > library(\"swirl\") > install_course(\"Course Name Here\") # 课程列表参考 https://github.com/swirldev/swirl_courses > swirl() 后面就是按照提醒一步步操作，先给自己起个名字，然后选择课程。我选择的是 R Programming，最后选择课时。 swirl 的其他命令 可输入 info() 查看 > info() | When you are at the R prompt (>): | -- Typing skip() allows you to skip the current question. | -- Typing play() lets you experiment with R on your own; swirl will ignore | what you do... | -- UNTIL you type nxt() which will regain swirl's attention. | -- Typing bye() causes swirl to exit. Your progress will be saved. | -- Typing main() returns you to swirl's main menu. | -- Typing info() displays these options again. R Programming 课程目录 [x] 1. Basic Building Blocks [x] 2. Workspace and Files [x] 3. Sequences of Numbers [x] 4. Vectors [x] 5. Missing Values [x] 6. Subsetting Vectors [x] 7. Matrices and Data Frames [x] 8. Logic [x] 9. Functions [x] 10. lapply and sapply [x] 11. vapply and tapply [x] 12. Looking at Data [x] 13. Simulation [x] 14. Dates and Times [x] 15. Base Graphics Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 15:56:20 "},"R/RProgramming/lesson1.html":{"url":"R/RProgramming/lesson1.html","title":"基本构件","keywords":"","body":"Lesson 1: 基本构件 本课时，我们将探索一些 R 语言的基本构件。 如需帮助，可以使用 help.start()。 最简单的形式，R 语言可用作交互式计算器： > 5 + 7 [1] 12 我们可以创建一个变量来储存计算结果，而不用每次都重新输入 5 + 7 ，在 R 语言中，给变量赋值使用的符号是 （小于号后面跟一个减号）。 可以把这个分配运算符看作一个箭头，把箭头右侧的值赋给左侧的变量，例如： > x 你可能注意到了，R 并没有直接输出计算结果 12，当你使用分配运算符时，R 假设你不想立即看到计算结果，而是倾向于之后要使用此计算值。如果想查看变量 x 的内容，直接输入 x，然后按 Enter， > x [1] 12 下面创建一个新变量 y ，使 y = x - 3 > y y [1] 9 使用 y 或 y ，完全取决与你的个人习惯，但是在每个分配运算符两侧各留一个 空格 是个很好的习惯。 现在，让我们创建一个称为 向量 的小的数字集合。 在 R 语言中，任何包含数据的对象都可称为一个数据结构，而数值向量是最简单的数据结构类型。 最简单的创建一个向量的方式是使用 c() 函数, 它代表的意思是 concatenate 或 combine。下面创建一个包含数字 1.1，9 和 3.14 的向量 z： > z z [1] 1.10 9.00 3.14 如果对某个特定函数存在疑问，可以使用 \"?\" 命令访问 R 自带的帮助文件，例如，如果想得到 c() 函数更多的信息，可以输入 ?c 查看（不用输入括号）。 > ?c c package:base R Documentation Combine Values into a Vector or List Description: This is a generic function which combines its arguments. The default method combines its arguments to form a vector. All arguments are coerced to a common type which is the type of the returned value, and all attributes except names are removed. Usage: ... 下面我们创建一个包含 z 和 555 的新向量。 > c(z, 555) [1] 1.10 9.00 3.14 555.00 再创建一个向量 c(z, 555, z) > c(z, 555, z) [1] 1.10 9.00 3.14 555.00 1.10 9.00 3.14 数值向量能被用于算术运算。例如： > z * 2 + 100 [1] 102.20 118.00 106.28 首先是每个元素乘以 2，然后每个元素的计算结果再加上 100. 其他常见的数学运算符有 \"+\", \"-\", \"/\", 和 \"^\"(squared 平方)。使用函数 sqrt() 得到平方根，以及使用 abs() 函数得到绝对值。 创建一个新函数 my_sqrt, 求 z-1 的平方根： > my_sqrt my_sqrt [1] 0.3162278 2.8284271 1.4628739 R 首先会将向量 z 的每个元素减去 1，然后是每个结果独立开平方根，得到的是和向量 z 长度一样的新的向量。 创建一个新的向量 my_div，使其等于 向量 z 除于 my_sqrt: > my_div my_div [1] 3.478505 3.181981 2.146460 在之前的例子中，当我们计算 z * 2 + 100 时，z 是一个长度为 3 的向量，但是技术上说， 2 和 100 是长度为 1 的向量。其背后的含义是，R 再循环 制造了一个向量 2s 和一个向量 100s，换句话说，当你要求 R 计算 z * 2 + 100 时，它真实计算的是：z * c(2, 2, 2) + c(100, 100, 100). 为了了解 再循环 机制时如何运作的，我们看另一个例子，试着做一个运算，c(1, 2, 3, 4) + c(0, 10) > c(1, 2, 3, 4) + c(0, 10) [1] 1 12 3 14 如果长向量的长度 不是 短向量的倍数，R 仍会应用 再循环 机制，但是会弹出一个警告，让你知道有些怪怪的事情正在运行。例如，我们尝试运行 c(1, 2, 3, 4) + c(0, 10, 100) > c(1, 2, 3, 4) + c(0, 10, 100) [1] 1 12 103 4 Warning message: In c(1, 2, 3, 4) + c(0, 10, 100) : longer object length is not a multiple of shorter object length Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-04-02 15:10:08 "},"R/RProgramming/lesson2.html":{"url":"R/RProgramming/lesson2.html","title":"工作空间和文件","keywords":"","body":"Lesson 2: 工作空间和文件 在本节课，你将能学到，在 R 语言中如何检查你的当地工作空间，以及开始探索工作空间与机器的文件系统之间的关系。 因为不同操作系统在处理事情比如文件路径等有不同的规定，这些命令的输出结果也可能因机器而异。不管怎么说，重要的是，R 语言为与文件交互提供了一个通用 API. getwd() 获取本 R 课程当前运行的目录： > getwd() [1] \"/root\" ls() 列出您当前工作空间的所有项目： > ls() [1] \"my\" \"my_div\" \"my_sqrt\" \"mydiv\" \"x\" \"y\" \"z\" 对 x 赋值 9 > x ls() [1] \"my\" \"my_div\" \"my_sqrt\" \"mydiv\" \"x\" \"y\" \"z\" list.files() 或 dir() 列出在本工作目录下的所有文件： > list.files() [1] \"1\" \"anaconda3\" [3] \"gitback.sh\" \"gitback.sh.save\" [5] \"install.sh\" \"JupyterLab\" 使用 ?list.files 查看更多信息 args() 查看函数可以采用什么样的参数。 例如，查看 list.files() 函数可以使用什么参数： > args(list.files) function (path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) NULL 将当前工作目录赋值给变量 old.dir: > old.dir 我们可以在课程结束时用此变量返回到我们开始的地方。许多像 getwd() 这样的询问函数有个非常有用特性，可以返回问题的答案为一个函数的结果。 dir.create() 在当前工作目录下创建一个名为 testdir 的目录。 > dir.create(\"testdir\") setwd() 设置当前目录为 testdir > setwd(\"testdir\") 通常，你想设置你的工作目录为某些敏感的地方，也许需要创建你正在运行的特有项目。事实上，组织你的 R 包方面的工作，使用 RStudio 是个明智的选择。下载 Rstudio 在 http://www.rstudio.com/ file 系类函数 file.create() 在当前工作目录下创建一个名为 mytest.R 的文件： > file.create('mytest.R') [1] TRUE # 这个文件就时该工作目录下的唯一的文件，查看一下： > list.files() [1] \"mytest.R\" file.exists() 检查当前工作目录下是否存在 mytest.R 文件： > file.exists(\"mytest.R\") [1] TRUE file.info() 查看文件 mytest.R 的信息： > file.info(\"mytest.R\") size isdir mode mtime ctime mytest.R 0 FALSE 644 2020-03-09 22:49:36 2020-03-09 22:49:36 atime uid gid uname grname mytest.R 2020-03-09 22:49:36 0 0 root root 可以使用 $ 运算符，比如 file.info('mytest.R')$mode --- 获得特定的项目 file.rename() 重命名 mytest.R 为 mytest2.R > file.rename('mytest.R','mytest2.R') [1] TRUE file.copy() 备份 mytest2.R 为 mytest3.R: > file.copy('mytest2.R','mytest3.R') [1] TRUE file.remove() 移除文件 file.path() 提供某文件的相对路径： > file.path('mytest3.R') [1] \"mytest3.R\" 可以利用这个特性获得文件夹的相对路径，例如： > file.path(\"folder1\", \"folder2\") [1] \"folder1/folder2\" dir.create() ?dir.create 查看帮助文件，注意 recursive 参数，为了创建嵌套目录，recursive 应设为 TRUE. > ?dir.create files2 package:base R Documentation Manipulation of Directories and File Permissions Description: These functions provide a low-level interface to the computer's file system. Usage: dir.exists(paths) dir.create(path, showWarnings = TRUE, recursive = FALSE, mode = \"0777\") Sys.chmod(paths, mode = \"0777\", use_umask = TRUE) Sys.umask(mode = NA) Arguments: path: a character vector containing a single path name. Tilde expansion (see ‘path.expand’) is done. paths: character vectors containing file or directory paths. Tilde expansion (see ‘path.expand’) is done. showWarnings: logical; should the warnings on failure be shown? recursive: logical. Should elements of the path other than the last be created? If true, like the Unix command ‘mkdir -p’. mode: the mode to be used on Unix-alikes: it will be coerced by ‘as.octmode’. For ‘Sys.chmod’ it is recycled along ‘paths’. use_umask: logical: should the mode be restricted by the ‘umask’ setting? Details: ··· 在当前工作目录下，创建一个名为 testdir2 的文件夹，以及一个名为 testdir3 的子文件夹（这利用到之前提到的 file.path() 的特性）。 > dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE) 使用 setwd() 函数返回原来的工作目录（可重新调用之前创建的变量 old.dir） > setwd(old.dir) 这对于保存之前的设置，开始一个分析，然后在结束时返回起始位置十分有帮助。 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-10 22:36:05 "},"R/RProgramming/lesson3.html":{"url":"R/RProgramming/lesson3.html","title":"数列","keywords":"","body":"Lesson 3: 数列 这节课，学习在 R 中如何创建数列。 在 R 中，最简单的创建数列的方式是使用 : 运算符，输入 1：20 查看它是如何运作的： > 1:20 [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 它的输出值为 1-20 的所有整数。 我们也能用它创建实数数列。例如： > pi:10 [1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593 结果是从 pi 开始，递增间隔为 1 的实数向量。上限 10 是不可能达到的，因为它的下一个数据大于 10. 如果输入 15:1 会发生什么？ 试一下： > 15:1 [1] 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 返回的结果为一组递减数列。 学习 R 时，有任何不清楚的函数功能，都可以通过查询 R 自带的帮助文档获得，此处查看一下':'运算符的详细信息： > ?':' The binary operator ‘:’ has two meanings: for factors ‘a:b’ is equivalent to ‘interaction(a, b)’ (but the levels are ordered and labelled differently). For other arguments ‘from:to’ is equivalent to ‘seq(from, to)’, and generates a sequence from ‘from’ to ‘to’ in steps of ‘1’ or ‘-1’. Value ‘to’ will be included if it differs from ‘from’ by an integer up to a numeric fuzz of about ‘1e-7’. Non-numeric arguments are coerced internally (hence without dispatching methods) to numeric-complex values will have their imaginary parts discarded with a warning. Value: For numeric arguments, a numeric vector. This will be of type ‘integer’ if ‘from’ is integer-valued and the result is representable in the R integer type, otherwise of type ‘\"double\"’ (aka ‘mode’ ‘\"numeric\"’). For factors, an unordered factor with levels labelled as ‘la:lb’ and ordered lexicographically (that is, ‘lb’ varies fastest). References: ··· Examples: 1:4 pi:6 # real 6:pi # integer f1 通常情况下，在创建数列时，我们想获得比 ':' 运算符提供的更多的自由度， seq() 函数可以满足我们的目的。 seq() 函数最基本的用法和 : 运算符一样，例如 seq(1, 10): > seq(1, 20) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 结果与 1:20 一致。如果要创建一个增幅为 0.5，范围在 0-10 的数列，可以使用 seq(0, 10, by=0.5) > seq(0, 10, by = 0.5) [1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 [16] 7.5 8.0 8.5 9.0 9.5 10.0 如果我们不关心增幅，只是想获得5-10范围内的30个数字，seq(5 ,10, length=30) 可以达到这个目的。尝试一下，并将结果赋值给变量 my_seq > my_seq 为了确认 my_seq 变量的长度为 30，可以使用 length() 函数。 > length(my_seq) [1] 30 假设我们不知道 my_seq 的长度，但是我们想生成一个从1到N的整数数列，N代表的是向量 my_seq 的长度。 换句话说，我们想创建一个新的向量 (1,2,3,···)，它的长度与 my_seq 相同。 有几种方法可以实现。一种方式是结合 : 运算符和 length() 函数，就像 1:length(my_seq) 这样，我们试一下： > 1:length(my_seq) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 另一种方式是使用 seq(along.with = my_seq) 函数： > seq(1, along.with = my_seq) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 不管怎么样，与许多常见任务一样，R 有一个独立的能提供此功能的内置函数，称为 seq_along(), 我们试一下： > seq_along(my_seq) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [26] 26 27 28 29 30 在 R 语言中，还有几种方式可以解决这个问题。当你成为高级的R语言程序员，你可以设计你自己的函数来解决那些没有更好选择时的问题。在将来的课程中，我们将探索如何编写你自己的函数。 另一个与创建数列相关的函数是 rep(), 其含义是 replicate, 下面来看一下它的一些用法。 如果我们想要创建一个包含 40个零的向量，可以使用 rep(0, times = 40): > rep(0, times = 40) [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 [39] 0 0 如果想创建一个重复 10次 (0, 1, 2)的向量，可以执行 rep(c(0, 1, 2), times = 10). > rep(c(0, 1, 2), times = 10) [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 如果想创建一个重复10次0，然后重复10次1，最后再重复10次2的向量，可以使用 each 参数，试一下 rep(c(0, 1, 2), each = 10): > rep(c(0, 1, 2), each = 10) [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-10 22:36:05 "},"R/RProgramming/lesson4.html":{"url":"R/RProgramming/lesson4.html","title":"向量","keywords":"","body":"Lesson 4: 向量 R 语言中最简单以及最常用的数据结构是向量。 向量有两类：原子向量 和 列表。原子向量仅包含一种数据类型，而列表可以包含多种数据类型。 在之前的课程中，我们处理的都是是数字向量，这是原子向量的一种类型。其他的原子向量类型包括逻辑向量，整数向量，双向量和字符向量。整数和双向量统称为数字向量。本课程中，我们来学习下逻辑向量和字符向量。 逻辑向量 逻辑向量包含的值是 TRUE, FALSE 和 NA (意思是 not availabel)。这些值由逻辑 条件 的结果生成。我们来试一些简单的条件。 首先，创建一个名为 num_vect 的数字向量，包含(0.5, 55, -10, 6). > num_vect 现在，创建一个称为 tf 的变量，得到 num_vect 的结果。 > tf 你认为 tf 的结果是什么样的呢？是一个逻辑值，还是一个包含 4 个逻辑值的向量呢？我们看一下结果： > tf [1] TRUE FALSE TRUE FALSE num_vect 是个判断条件，tf 会判断每个元素是否符合判断条件，然后返回每个元素的逻辑值。 我们来尝试另一个判断条件： > num_vect >= 6 [1] FALSE TRUE FALSE TRUE 上述例子中的 和 >= 符号称为逻辑运算符，其他的逻辑运算符有：>, , ==(等于) 和 !=(不等于). 如果有两个逻辑表达式呢，比如 A | B 表示 A 或 B 至少一个为 TRUE 的判断结果，A & B 表示 A 和 B 都是 TRUE 的判断结果。比如下面这些例子： | (3 > 5) & (4 == 4) 1: FALSE 2: TRUE Selection: 1 | Your dedication is inspiring! | (TRUE == TRUE) | (TRUE == FALSE) 1: TRUE 2: FALSE Selection: 1 | Nice work! | ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5) 1: TRUE 2: FALSE Selection: 1 | Your dedication is inspiring! 字符向量 字符向量也在 R 语言中十分普遍。区分字符串可使用双引号(\"\")。 创建一个名为 my_char 的字符串向量，使其包含下列单词：\"My\", \"name\", \"is\". > my_char my_char [1] \"My\" \"name\" \"is\" my_char 是一个长度为 3 的字符向量，如果想将字符向量转换成一个字符串（可以看成是一个元素数为 1 的向量），可以使用 paste() 函数： > paste(my_char, collapse = \" \") [1] \"My name is\" collapse 参数是告诉 R，我们想用 单空格 分隔开 my_char 中的元素。 使用 c() 函数在 my_char 后面添加内容： > my_name my_name [1] \"My\" \"name\" \"is\" \"Daddy\" 再次使用 paste() 函数，将 my_name 转换成一个单独的字符串，不要忘了加上 collapse = \" \"! > paste(my_name, collapse = \" \") [1] \"My name is Daddy\" 在一些简单的例子中，可以使用 paste() 做两个长度为 1 的字符串的加法，例如 paste(\"Hello\", \"world!\", sep = \" \")，sep 参数的意思是用空格分隔开两个加入的元素。 > paste(\"Hello\", \"world!\", sep = \" \") [1] \"Hello world!\" 下面我们将一个整数向量与字符串向量相加： > paste(1:3, c(\"X\", \"Y\", \"Z\"), sep = \"\") [1] \"1X\" \"2Y\" \"3Z\" 如果两个相加的向量长度不同该如何？（我们之前谈论过，向量回收机制（再循环机制？如何翻译？） > paste(LETTERS, 1:4, sep = \"-\") [1] \"A-1\" \"B-2\" \"C-3\" \"D-4\" \"E-1\" \"F-2\" \"G-3\" \"H-4\" \"I-1\" \"J-2\" \"K-3\" \"L-4\" [13] \"M-1\" \"N-2\" \"O-3\" \"P-4\" \"Q-1\" \"R-2\" \"S-3\" \"T-4\" \"U-1\" \"V-2\" \"W-3\" \"X-4\" [25] \"Y-1\" \"Z-2\" LETTERS 是 R 预定义的变量，是包含了全部 26 个英语字母的字符串向量。 因为字符向量 LETTERS 长于数字向量 1:4，所以 R 简单的循环，重复，直到 1：4 匹配到 LETTERS 的长度。 不值一提的是，数字向量 1:4 可以使用 paste() 函数 强制融合 进字符向量。我们会在其他课程中探讨 强制融合 的机制，但是它的真实含义是数字 1，2，3 和 4，在输出的结果中对 R 来说，不再是数字，而是字符串 \"1\", \"2\", \"3\" 和 \"4\". Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-11 11:32:29 "},"R/RProgramming/lesson5.html":{"url":"R/RProgramming/lesson5.html","title":"缺失值","keywords":"","body":"Lesson 5: 缺失值 缺失值在统计和数据分析中发挥着重要的作用。通常情况下，缺失值不能被忽略，而且应该被仔细研究来判断是否存在潜在的模式或原因导致了缺失值的形成。 NA 在 R 语言中，NA 代表的意思是不可用(not availabel) 或 缺失(missing，在统计学意义上)，本课程，我们将进一步探讨缺失值。 任何涉及 NA 的操作通常都会生成 NA。为了说明，我们创建一个向量 c(44, NA, 5, NA)，并将其值赋予变量 x。 > x x * 3 [1] 132 NA 15 NA 注意，向量 x 中的 NA 值元素，在结果向量中仍是 NA。 为了让事情更加有趣，我们创建一个向量 y，使其包含 1000 个符合标准正态分布的值。 > y 然后，创建一个包含 1000 个 NA 的向量 z： > z 最后，从这 2000 个值(y 和 z)中随机选择 100 个，我们不清楚这些值中包含了多少个 NA 值： > my_data 首先，我们想知道 NA 位于 my_data 的位置，is.na()函数会告诉我们向量的每一个元素是否是 NA： my_na my_na [1] FALSE TRUE TRUE FALSE TRUE FALSE TRUE FALSE FALSE TRUE TRUE FALSE [13] FALSE FALSE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE [25] TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE TRUE FALSE TRUE FALSE [37] TRUE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE TRUE TRUE TRUE [49] FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE TRUE TRUE FALSE [61] TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE TRUE FALSE TRUE TRUE [73] FALSE TRUE TRUE FALSE TRUE TRUE FALSE TRUE FALSE TRUE FALSE TRUE [85] FALSE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE TRUE [97] FALSE TRUE FALSE TRUE 每一个 TRUE，表示的即是 NA，而每一个 FALSE，表示这个值是来自标准正态分布的随机值。 在之前的逻辑运算符的讨论中，我们介绍了 == 运算符，可以测试两个项目是否相等。因此，我们认为 my_data == NA 也能生成和 is.na() 一样的运算符。来试一下： > my_data == NA [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA 我们得到的结果却是一个全是 NA 的向量，这是因为，确切的说 NA 不是一个具体的值，它仅是一个不可用的数据的占位符，因此这个逻辑表达式是不完整的，R 只能返回一个和 my_data 长度一致，全是 NA 的向量。 不用担心是否这点让人困惑。关键是任何时候使用逻辑表达式时都要谨慎，因为单个 NA 可能会破环掉整个过程。 回到手头的任务，现在我们有了一个向量 my_na，它包含了每个元素是否是 NA 的逻辑值，我们也能计算出数据中有多少个 NA。 诀窍是认识到在表面之下，R 表示数字 1 为真，数字 0 为假。因此，如果我们取一堆真值和假值的和，我们就得到真值的总数。 我们来试一试，在 my_na 上调用 sum() 函数来计算其真值的数量，也就是 my_data 中 NA 的数量。 > sum(my_na) [1] 56 最后，让我们来看看数据，一切都“合起来”。将 my_data 输出到控制台： > my_data [1] -0.28801435 NA NA 0.36748726 NA -1.19633286 [7] NA 0.66454307 -1.00578082 NA NA 1.81471621 [13] 2.17424903 -1.71439226 NA -0.24878883 NA NA [19] NA NA NA NA -1.02406254 NA [25] NA -1.15460010 -0.39492211 0.26074351 NA NA [31] NA -2.90531031 NA -2.33724788 NA -1.13759834 [37] NA 0.26175013 -1.52020692 NA NA NA [43] -2.23693352 0.92138647 -1.46456656 NA NA NA [49] 1.36848127 -0.41126305 -1.05480267 NA NA NA [55] NA -0.32308052 0.37748786 NA NA 0.52518884 [61] NA NA -0.24748836 NA -1.42900373 NA [67] NA NA NA -0.72784037 NA NA [73] -0.39686325 NA NA -2.35212605 NA NA [79] -0.02377080 NA -0.00310782 NA 1.41064101 NA [85] -0.50119562 NA NA 1.95195002 0.29982655 -1.01580805 [91] -0.65818903 NA NA 2.24820040 -0.31970510 NA [97] -1.09487594 NA -0.16355008 NA NaN 现在我们已经了解了 NA，让我来看缺失值的第二种类型：NaN，它代表的是非数字(not a number)。要生成 NaN，现在试一下 0 除于 0(正斜杠)： > 0/0 [1] NaN 我们再做一次，只是为了好玩。在 R 中，Inf 代表的是无穷，如果 Inf 减去 Inf 会发生什么？ > Inf - Inf [1] NaN Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-12 17:27:53 "},"R/RProgramming/lesson6.html":{"url":"R/RProgramming/lesson6.html","title":"子集向量","keywords":"","body":"Lesson 6: 子集向量 在这节课中，我们将看到如何根据我们指定的一些条件从向量中提取元素。 例如，我们也许只对一个向量的前 20 个元素感兴趣，活着仅对那些不是 NA 的元素感兴趣，或者只对那些是正的或者对应于一个特定的感兴趣的元素感兴趣。本课结束时，你将了解如何处理这些场景。 我们已经创建了一个向量 x，它包含了从标准正态分布中随机选取的 20 个数字，以及 20 个 NA。现在输入 x，看它是否是这样的： > x [1] NA NA -0.01301518 NA NA NA [7] -0.47721718 NA 0.23556194 NA NA NA [13] -0.56827616 NA -1.39451656 0.20122132 0.09755386 2.47619742 [19] -0.08464506 0.80707804 -0.28220555 -0.85445817 1.65740981 NA [25] NA 0.19560065 NA NA -0.84176773 0.30555518 [31] NA 0.27902072 NA NA 0.91157021 NA [37] NA -0.70343162 NA -0.64953318 你告诉 R 你想从向量中选择一部分元素(比如：一个子集)的方法是在向量的名字后面的方括号中放置一个“索引向量”。 比如一个简单的例子，试一下 x[1:10] 来查看向量 x 的前 10 个元素。 > x [1:10] [1] NA NA -0.01301518 NA NA NA [7] -0.47721718 NA 0.23556194 NA 索引向量有四种不同的形式：逻辑向量，正整数的向量，负整数的向量，字符串的向量。每一个我们在这节课都会讲到。 让我们从逻辑向量建立索引开始。在处理真实数据时，一个常见的场景时我们想要提取一个向量中不是 NA 的所有元素。回想一下，is.na(x) 生成了一个长度于 x 相同的逻辑值向量，其 TRUE 对应于 x 中的 NA，FALSE 对应于 x 中的非 NA 值。 考虑一下，x[is.na(x)] 会返回什么结果： > x [is.na(x)] [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA 提取的是所有的 NA 值。 回想一下，! 给我们一个逻辑表达式的否定式，所有 !is.na(x) 可以被解读为 is not NA。因此，我们想要创建一个包含所有来自 x 的非 NA 值的向量 y，我们可以使用 y , 试试吧： > y y [1] 1.58802569 -1.01293755 0.37155713 1.69750561 -1.60847397 0.60249903 [7] -0.41862256 -0.48870077 1.18646771 -0.54252969 -0.97333657 1.13544799 [13] 0.06677423 0.56186192 0.16981586 -1.26339820 -0.78870739 -0.41639811 [19] -0.17735571 -2.33724788 现在我们已经隔离了 x 的非缺失值，并将它们放入 y 中，子集 y 就是我们想要的。 回想一下，表达式 y > 0 将给我们一个逻辑值向量，它的长度与 y 相同，TRUE 对应于大于 0 的 y 的值，FALSE 对应于小于等于 0 的 y 的值。你认为 y[y > 0] 会返回什么？试一下： > y [y > 0] [1] 1.58802569 0.37155713 1.69750561 0.60249903 1.18646771 1.13544799 0.06677423 [8] 0.56186192 0.16981586 你也许想知道为什么我们一开始不用 x[x > 0] 来提取 x 中的正值元素，试一下看下结果： > x [x > 0] [1] NA NA NA 1.58802569 NA NA [7] 0.37155713 NA 1.69750561 NA 0.60249903 NA [13] NA NA 1.18646771 NA NA 1.13544799 [19] NA 0.06677423 NA NA 0.56186192 0.16981586 [25] NA NA NA NA NA 因为 NA 不是一个值，而是一个未知数的占位符，所以表达式 NA > 0 的结果为 NA。因此，当我们这样做的时候，我们得到了一堆和我们的正数混合在一起的 NA。 结合逻辑运算和子集的知识，我可以这样做，x[!is.na(x) & x > 0]，试一下： > x [!is.na(x) & x > 0] [1] 1.58802569 0.37155713 1.69750561 0.60249903 1.18646771 1.13544799 0.06677423 [8] 0.56186192 0.16981586 在本例中，我们只请求了非缺失值且大于零的 x 值。 我已经向您展示了如何使用 x[1:10] 来子集化 x 的前十个值。在本例中，我们在方括号内提供了一个正整数向量，它告诉 R 只返回编号为 1 到 10 的 x 的元素。 许多编程语言使用所谓的“从零开始的索引”，这意味着向量的第一个元素被认为是元素 0。R 使用“基于 1 的索引”，这意味着一个向量的第一个元素被认为是元素 1。 您能指出我们如何将 x 的第 3、5 和 7 个元素子集化吗? 提示：使用 c() 函数将元素编号指定为数字向量。 > x [c(3, 5, 7)] [1] 1.969917 NA NA 重要的是，当使用整数向量来子集化向量 x 时，我们坚持使用索引集 {1, 2, ..., 40}, 因为 x 只有 40 个元素。如果我们提取 x 的第 0 个元素（即 x [0] ），试一下会发生什么。 > x [0] numeric(0) 正如你所料，我们没有得到任何有用的东西。不行的是，R 并灭有阻止我们这样做。如果我们提取 x 的第 3000 个元素呢，试一下。 > x [3000] [1] NA 同样，没什么有用的，但 R 不阻止我们提出要求。这是个警示。你应该确保你所提取的是在你所处理向量的范围内。 如果我们对 x 除了第 2 个和第 10 个元素以外的所有元素感兴趣呢？如果列出所有的数字索引将是很乏味的。 幸运的是，R 接受负整数索引。x[c(2, 10)] 只给出了 x 的第 2 和第 10 个元素，而 x[c(-2, -10)] 给出了除第 2 和第 10 个以外的所有 x 的元素。输入 x[c(-2, -10)] 来看看。 > x [c(-2, -10)] [1] NA 1.96991716 -0.00232278 NA NA NA [7] NA NA NA -0.11091275 0.10989098 NA [13] 0.27947713 -0.57222361 NA 0.65100583 0.41413828 -0.64963226 [19] -0.15977023 NA NA NA 1.53372448 -0.47685392 [25] NA -0.25140323 1.40447082 NA 1.47180257 NA [31] NA 1.47247464 NA -0.08781325 0.78578649 NA [37] NA 1.90042642 指定多个负数的一种简便方法是将负数放在正数向量的前面。输入 x[-c(2, 10)] 来得到完全相同的结果。 > x [-c(2, 10)] [1] NA 1.96991716 -0.00232278 NA NA NA [7] NA NA NA -0.11091275 0.10989098 NA [13] 0.27947713 -0.57222361 NA 0.65100583 0.41413828 -0.64963226 [19] -0.15977023 NA NA NA 1.53372448 -0.47685392 [25] NA -0.25140323 1.40447082 NA 1.47180257 NA [31] NA 1.47247464 NA -0.08781325 0.78578649 NA [37] NA 1.90042642 到目前为止，我们已经介绍了三种类型的索引向量，逻辑型，正整数型和负整数型。剩下的唯一类型要求我们引入“命名”元素的概念。 创建一个包含三个命名元素的数字向量 vect . > vect 当我们将 vect 打印到控制台时，你将看到每个元素都有一个名称。试一下。 > vect foo bar norf 11 2 NA 我们还可以通过将 vect 作为参数传递给 names() 函数来获得 vect 的名称。试试吧。 > names(vect) [1] \"foo\" \"bar\" \"norf\" 活着，我们可以用 c(11, 2, NA) 创建一个未命名的向量 vect2. 现在试一下。 > c(11, 2, NA) [1] 11 2 NA 创建一个名为 vect2 的普通（未命名）向量，其中包含 c(11, 2, NA). > vect2 然后，我们可以使用 names(vect2) 将 names 属性添加到 vect2 中。去做吧。 > names(vect2) 现在，让我们利用 identical() 函数来检查 vect 和 vect2 是否相同。 > identical(vect, vect2) [1] TRUE 事实上，vect 和 vect2 是相同的命名向量。 现在，回到通过命名元素设置向量子集的问题上。你认为下面哪一个会提取出 vect 的第二个元素？ 1: vect [bar] 2: vect [\"2\"] 3: vect [\"bar\"] 答案是第三个，试一下。 > vect [\"bar\"] bar 2 同样，我们可以用 vect[c(\"foo\", \"bar\")] 来指定一个名称向量。试一下。 > vect [c(\"foo\", \"bar\")] foo bar 11 2 现在你已经了解了从向量中设置数据子集的四种方法。不同的方法在不同的情况下是最好的，如有疑问，尝试一下！ Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-18 22:32:57 "},"R/RProgramming/lesson7.html":{"url":"R/RProgramming/lesson7.html","title":"矩阵和数据框","keywords":"","body":"Lesson 7: 矩阵和数据框 在本节课中，我们将学习矩阵和数据框。它们都表示”矩形“数据类型，这意味着他们用于存储具有行和列的表格数据。 正如你将看到的，主要区别在于，矩阵只能包含一类数据，而数据框可以包含许多不同类的数据。 让我们使用 : 创建一个包含数字 1 到 20 的向量。将结果存储在名为 my_vector 的向量中。 > my_vector my_vector [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dim() 函数告诉我们对象的”维数“。如果我们输入 dim(my_vector) 会发生什么？试一下。 > dim(my_vector) NULL 显然，这没有多大帮助！因为 my_vector 是一个向量，它没有 dim 属性，但是我们可以使用 length() 函数来得到它的长度。现在试一试。 > length(my_vector) [1] 20 这就是我们想要的答案。但是，如果我们给向量一个 dim 属性会发生什么？让我们来试一下。输入 dim(my_vector) . > dim(my_vector) 如果你觉得最后一条命令有点奇怪，也没关系，它本来就是这样。dim() 函数允许你获取或者设置 R 对象的 dim 属性。在本例中，我们将值 c(4, 5) 赋给向量的 dim 属性。 使用 dim(my_vector) 来确认我们已经正确地设置了 dim 属性。 > dim(my_vector) [1] 4 5 另一种查看的方式是对 my_vector 使用 attributes() 函数。 > attributes(my_vector) $dim [1] 4 5 就像在数学课上一样，当我们处理一个二维对象（比如矩形表）时，第一个是行数，第二个是列数。因此，我们赋予了 my_vector 4 行 5 列。 但是，等等！这听起来不再像向量了。是的，现在它是一个矩阵。现在查看向量的内容，看看它是什么样子的。 > my_vector [, 1] [, 2] [, 3] [, 4] [, 5] [1,] 1 5 9 13 17 [2,] 2 6 10 14 18 [3,] 3 7 11 15 19 [4,] 4 8 12 16 20 现在，让我们使用 class() 函数来确认一下它是否是一个矩阵。输入 class(my_vector) 开查看我的意思。 > class(my_vector) [1] \"matrix\" 当然，my_vector 现在是一个矩阵。我们应该储存它用一个新的变量来帮助我们记住它是什么。存储 my_vector 的值为新向量 my_matrix 。 > my_matrix 到目前为止我们使用的示例是为了说明一个观点，即矩阵只是一个具有维度属性的原子向量。创建相同矩阵的更直接的方法是使用 matrix() 函数。 现在使用 ? 函数打开 matrix() 函数的帮助文件。 > ?matrix matrix package:base R Documentation Matrices Description: ‘matrix’ creates a matrix from the given set of values. ‘as.matrix’ attempts to turn its argument into a matrix. ‘is.matrix’ tests if its argument is a (strict) matrix. Usage: matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) as.matrix(x, ...) ## S3 method for class 'data.frame' as.matrix(x, rownames.force = NA, ...) is.matrix(x) ... Examples: is.matrix(as.matrix(1:10)) ! is.matrix(warpbreaks) # data.frame, NOT matrix! warpbreaks [1:10,] as.matrix(warpbreaks [1:10,]) # using as.matrix.data.frame(.) method ## Example of setting row and column names mdat 现在，查看 matrix 函数的文档，看看是否可以通过调用 matrix() 函数来创建包含相同数字（1-20）和维数（4 行，5 列）的矩阵。将结果存储在一个名为 my_matrix2 的变量中。 > my_matrix2 最后，让我们来确认一下 my_matrix 和 my_matrix2 是否完全一致。 identical() 函数将告诉我们两个参数是否相同。试一下。 > identical(my_matrix, my_matrix2) [1] TRUE 现在，假设表格中的数字表示来自临床实验的一些测量值，其中每一行表示一个患者，每一列表示测量的一个变量。 我们可能想要标记这些行，以便我们知道哪些数字属于实验中的哪位病人，一种方法是向矩阵中添加一列，其中包含所有四个人的名字。 让我们从创建一个字符向量开始，其中包含我们的病人的名字：Bill、Gina、Kelly 和 Sean。记住，双引号告诉 R 某个东西是字符串。将结果存储在一个名为 patients 的变量中。 > patients 现在我们将使用 cbind() 函数合并列。不要担心将结果存储在新变量中。只需调用 cbind() 的两个参数，patients 和 my_matrix。 > cbind(patients, my_matrix) patients [1,] \"Bill\" \"1\" \"5\" \"9\" \"13\" \"17\" [2,] \"Gina\" \"2\" \"6\" \"10\" \"14\" \"18\" [3,] \"Kelly\" \"3\" \"7\" \"11\" \"15\" \"19\" [4,] \"Sean\" \"4\" \"8\" \"12\" \"16\" \"20\" 我们的结果有点可疑！其将字符向量与我们的数字矩阵相结合，使得所有东西都用双引号括起来。这意味着剩下的是一个字符串矩阵，这可不行。 如果你还记得这堂课的开始，我告诉过你，矩阵只能包含一类数据。因此，当我们试图将字符向量与数字矩阵组合时，R 被迫将数字 “强迫” 转换成字符，因此也使用双引号。 这被称为 “隐性强迫”，因为我们没有要求它这么做。它只是发生。但是为什么不把病人的名字转换成数字呢我让你们自己思考这个问题。 因此，我们仍然面临一个问题，如何在不破坏数字数据完整性的情况下，表格中包含患者的姓名。试试下面的指令 my_data > my_data my_data patients X1 X2 X3 X4 X5 1 Bill 1 5 9 13 17 2 Gina 2 6 10 14 18 3 Kelly 3 7 11 15 19 4 Sean 4 8 12 16 20 看起来 data.frame() 函数允许我们将名称的字符向量存储在数字矩阵旁边。这正是我们所希望的。 在后台，data.frame() 函数接收任何数量的参数，并返回由原始对象组成的类 data.frame 的单个对象。 让我们调用 class() 函数来验证新创建的数据框的类别。 > class(my_data) [1] \"data.frame\" 还可以为数据框架的行和列分配名称，这是确定表格中哪一行值属于哪位患者的另一种可能的方法。 但是，既然我们已经解决了这个问题，那么让我们通过为数据框架的列指定名称来解决另一个问题，这样我们就可以知道每一列代表的度量类型。 因为我们有 6 列（包括病人姓名列），我们需要首先创建一个向量，其包含每一列的一个元素。创建一个包含 \"patient\", \"age\", \"weight\", \"bp\", \"rating\", \"test\" 名为 cnames 的字符向量。 > cnames 现在，使用 colnames() 函数为数据框设置 colnames 属性。这和本课前面学到 dim() 函数的用法相似。 > colnames(my_data) my_data patient age weight bp rating test 1 Bill 1 5 9 13 17 2 Gina 2 6 10 14 18 3 Kelly 3 7 11 15 19 4 Sean 4 8 12 16 20 在本节课中，我们学习了两个非常重要和常见的数据结构：矩阵和数据框，的基础知识。在以后的课程中，我们将学习更多的内容，特别是关于数据框的进阶课题。 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-18 22:32:57 "},"R/RProgramming/lesson8.html":{"url":"R/RProgramming/lesson8.html","title":"逻辑","keywords":"","body":"Lesson 8: 逻辑 本课是对 R 中的逻辑运算的简单介绍。 在 R 中，有两个逻辑值，也被称为布尔值。分别是 TRUE 和 FALSE 。在 R 中，你可以构造逻辑表达式，其结果是 TRUE 或 FALSE。本课的许多问题都涉及到逻辑表达式的计算。 逻辑运算符 创建逻辑表达式需要逻辑运算符，\"+\", \"-\", \"*\" 和 \"/\"。我们讨论的第一个逻辑运算符是等于运算，符号是 \"==\"。接下来使用等号运算符来看一下 TRUE 是否等于 FALSE。 > TRUE == FALSE [1] FALSE 使用等号运算符，键入 TURE == TRUE 试试。 > TRUE == TRUE [1] TRUE 就像数学一样，逻辑表达式可以通过括号进行分组，这样整个表达式 (TRUE == TRUE) == TRUE 的计算结果就为 TRUE. 要测试此属性，请尝试 (FALSE == TRUE) == FALSE。 > (FALSE == TRUE) == FALSE [1] TRUE 等号运算符也可以用来比较数字。使用 \"==\" 看看 6 是否等于 7. > 6 == 7 [1] FALSE 值得庆幸的是，有一些不等式运算符允许我们测试一个值是否小于或大于另一个值。 小于操作符可以判断左边的数字是否小于右边的数字。写一个表达式来测试 6 是否小于 7. > 6 还有一个小于等于操作符 \" > 10 当然，也有对应的 大于等于操作符 \">=\". 我们将讨论下一个运算符，不等于号 \"!=\" > 5 != 7 [1] TRUE # 等于运算符 > 5 == 7 [1] FALSE # 上述表达式的否定式 > !5 == 7 [1] TRUE # 还有其他的运算符，比如 \"and\" 和 \"and and\"，运算符为 \"&\" 和 \"&&\"。 > TRUE & TRUE [1] TRUE > FALSE & FALSE [1] FALSE > TRUE & c(TRUE, FALSE, FALSE) [1] TRUE FALSE FALSE # && 与 & 不同，&& 只与向量的第一个元素做比较 > TRUE && c(TRUE, FALSE, FALSE) [1] TRUE # |和||与&和||的用法类似，|是OR的意思。 > TRUE | c(TRUE, FALSE, FALSE) [1] TRUE TRUE TRUE > TRUE || c(TRUE, FALSE, FALSE) [1] TRUE 逻辑运算符的执行顺序。 > 5 > 8 || 6 != 8 && 4 > 3.9 [1] TRUE 从上述结果也可以看出，R的运算逻辑是先执行 &&，再执行 ||。 逻辑函数 还有其他函数也可以执行逻辑运算，比如 isTRUE(6 > 4) > isTRUE(6 > 4) [1] TRUE Which of the following evaluates to TRUE? 1: isTRUE(NA) 2: isTRUE(!TRUE) 3: !isTRUE(4 identical() 函数也可以做逻辑运算。 > identical('twins', 'twins') [1] TRUE Which of the following evaluates to TRUE? 1: identical(5 > 4, 3 xor() 函数也可执行逻辑运算。 xor() 函数的含义是判断两个元素是否互斥，如果两个元素一个为 TRUE，另一个为 FALSE，则 xor() 的返回结果为 TRUE，否则返回结果为 FALSE。 > xor(5 == 6, !FALSE) [1] TRUE Which of the following evaluates to FALSE? 1: xor(!isTRUE(TRUE), 6 > -1) 2: xor(identical(xor, 'xor'), 7 == 7.0) 3: xor(4 >= 9, 8 != 8.0) 4: xor(!!TRUE, !!FALSE) Selection: 3 为了下面几个问题，我们需要创建一个称为 ints 的整数向量。 > ints ints [1] 6 2 3 5 8 9 10 1 4 7 执行逻辑运算 ints > 5 > ints > 5 [1] TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE TRUE 使用 which() 函数找出 ints 中大于 7 的元素序号。 > which(ints > 7) [1] 5 6 7 Which of the following commands would produce the indices of the elements in ints that are less than or equal to 2? 1: which(ints 使用 any() 函数查看 ints 中是否有小于 0 的元素。 > any(ints 使用 all() 查看 ints 中所有元素都是大于零。 > all(ints > 0) [1] TRUE Which of the following evaluates to TRUE? 1: all(c(TRUE, FALSE, TRUE)) 2: any(ints == 10) 3: any(ints == 2.5) 4: all(ints == 10) Selection: 2 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 15:56:20 "},"R/RProgramming/lesson9.html":{"url":"R/RProgramming/lesson9.html","title":"函数","keywords":"","body":"Lesson 9: 函数 函数是 R 语言的基本构件之一。可以像对待其他 R 对象一样看待，是可重复使用的小段代码。 如果你已经学过这门课的其他部分，你可能已经用过一些函数。函数的特征通常是函数的名称后跟括号。 让我们尝试使用一些基本的函数来获得乐趣。Sys.Date() 函数的作用是返回一个代表今天日期的字符串。在下面输入 Sys.Date()，看看会发生什么。 > Sys.Date() [1] \"2020-03-25\" R 中的大多数函数都返回一个值。Sys.Date() 之类的函数基于计算机环境返回一个值，而其他函数则通过操作输入数据来计算返回值。 mean() 函数可以计算向量所有元素的平均值，下面我们以 c(2, 4, 5) 为参数，来计算其平均值。 > mean(c(2, 4, 5)) [1] 3.666667 函数的参数通常是函数所处理的变量。例如，mean() 函数介绍一个向量作为参数，就像例子 mean(c(2,6,8)) 一样。向量 mean() 将向量中的所有数字相加，然后除以向量的长度。 下面来定义一个函数，使其没有任何调整的输出输入的值。 boring_function 试一下这个函数： > boring_function('My first function!') [1] \"My first function!\" 要理解 R 中的计算，有两个口号(slogan)是有用的：1、存在的一切都是一个对象。2、发生的一切都是一个函数调用。 如果你想查看任何函数的源代码，只需键入函数名（不带括号和参数）。让我们来试一下，查看 boring_function 的源代码。 > boring_function function(x) { x } 下面我们来创建一个函数 my_mean()，使其能实现 mean() 的功能。 my_mean 现在试一下使用 my_mean() 函数来求向量 c(4, 5, 10) 的平均值。 > my_mean(c(4, 5, 10)) [1] 6.333333 接下来，让我们尝试写一个带有默认参数的函数。你可以为函数的参数设置默认值，如果使用此函数的人会在大多数情况下将某个参数设置为相同的值，那么这将非常有用。 remainder 我们来测试一下 remainder 函数。运行 remainder(5) 看看会发生什么。 > remainder(5) [1] 1 当只提供一个参数时，R 会匹配 num ，因为 num 是第一个参数。divisor 的默认值是 2，所以结果就和我们看到的一样。 接下来我们来测试一下提供两个参数的情况。键入 remainder(11, 5) 看看会发生什么。 > remainder(11, 5) [1] 1 参数再次被适当地匹配。 您还可以在函数中指定参数，当您通过名称指定参数值时，参数的顺序就不在重要了。键入 remainder(divisor = 11, num = 5) 来试一下。 > remainder(divisor = 11, num = 5) [1] 5 和你看到的一样，remainder(11, 5) 和 remainder(divisor = 11, num = 5) 明显不同。 R 中也可以只指定部分参数。试一下 remainder(4, div = 2) . > remainder(4, div = 2) [1] 0 警告：通常情况下，您希望使您的代码尽可能的容易理解。通过指定参数名或仅使用部分参数名而改变参数的顺序，这可能会造成混淆，因此要谨慎使用这些特性。 在所有这些关于参数的讨论中，您可能想知道是否还有方法来查看函数的参数（除查看文档外）。幸运的是，您可以使用 args() 函数。键入 args(remainder) 来查看 remainder 函数的参数。 > args(remainder) function (num, divisor = 2) NULL 您可能没有意识到我们骗你做了一些有趣的事情。args() 是函数，remainder() 也是函数，同时也 args() 的参数。是的，你可以把函数当作参数。这是个非常强大的概念。让我们来写个脚本来看一下它是如何作用的。 evaluate 我们来测试一下新函数，使用 evalute 函数来求向量 c(1.4, 3.6, 7.9, 8.8) 的标准差。 > evaluate(sd, c(1.4, 3.6, 7.9, 8.8)) [1] 3.514138 将函数作为其他函数的参数来传递的想法是编程中一个重要且基本的概念。 您可能会惊讶地发现，您可以将函数作为参数传递，而无需首先定义传递的函数。没有命名的函数被称为匿名函数。 我们使用 evaluate 函数来探索匿名函数是如何工作的。对于 evaluate 函数的第一个参数，我们要写一个很小的只适合一行的函数。在第二个参数中，我们将向第一个参数中的微型匿名函数传递一些数据。 键入 evaluate(function(x){x+1}, 6) 来讨论它是如何作用的。 > evaluate(function(x){x+1}, 6) [1] 7 第一个参数是一个微型的匿名函数，它使用参数 x 然后返回 x+1。我们将数字 6 传递给函数，因此整个表达式的计算结果是 7。 尝试使用 evaluate 函数来写一个匿名函数，使其返回向量 c(8, 4, 0) 的第一个元素。您的匿名函数应该仅采用一个变量 x 作为参数。 > evaluate(function(x){x[1]}, c(8, 4, 0)) [1] 8 现在尝试返回向量的最后一个元素。 > evaluate(function(x){x[length(x)]}, c(8, 4, 0)) [1] 0 本节课剩下的课程会频繁用到 paste() 函数。键入 ?paste 来查看文档。 正如您看到的，paste() 的第一个参数是 ... ，被称为省略号。省略号允许向函数传递不确定数量的参数。对于 paste() ，可以将任意数量的字符作为参数传递，而 paste() 将返回一个组合所有字符串的字符串。 看一下 paste() 是如何运作的，键入 paste(\"Programming\", \"is\", \"fun!\") > paste(\"Programming\", \"is\", \"fun!\") [1] \"Programming is fun!\" 是时候编写我们自己的修改版的 paste(). telegram 现在我们来测试您自己的 telegram 函数。 > telegram(\"x\") [1] \"START x STOP\" 我们尝试另一个函数。 mad_libs 是时候使用你的 mad_libs 函数了。确保为你的函数指定各个参数。 > mad_libs('x','y','z') [1] \"News from today where students took to the streets in protest of the new being installed on campus.\" 之前已经熟悉了加减乘除这些二进制运算符。在 R 中，你可以定义你自己的二进制运算符，在下一个脚本中，我将展示给你怎么做。 \"%p%\" 您创建了自己的二进制运算符！让我们来测试一下。使用新的二进制运算符将\"I\", \"love\", \"R!\" 粘贴在一起。 > \"I\" %p% \"love\" %p% \"R!\" [1] \"I love R!\" Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 15:56:20 "},"R/RProgramming/lesson10.html":{"url":"R/RProgramming/lesson10.html","title":"lapply 和 sapply 函数","keywords":"","body":"Lesson 10: lapply 和 sapply 本课总结 在本课中，您学习了如何使用强大的 lapply() 和 sapply() 函数对列表的元素进行操作。 lapply() 对列表应用一个函数，结果为列表。 sapply() 和 lapply() 的用法一样，但是它尝试简化 lapply() 的结果，所以结果可能是矩阵或向量。 本课详细内容 本节课中，您将学习如何使用 lapply() 和 sapply() 函数，这是 R 的 apply() 函数家族中最重要的两个成员，也称为循环函数。 这些强大的函数以及它们的近亲 ( vapply() 和 tapply() 等) 提供了一种简洁而方便的方法来实现用于数据分析的Split-Apply-Combine Strategy（化整为零的策略）。 每个应用函数将一些数据分割成更小的块，对每个块应用一个函数，然后合并出结果。 在本课中，我们将使用 UCI 机器学习仓库中的国旗数据集。此数据集中包含了各个国家及其国旗的详细信息。更多的信息可以参考： http://archive.ics.uci.edu/ml/datasets/Flags 让我们直接开始，这样你就能对这些特殊的函数是如何工作的有个感觉。 我将数据集存储在一个名为 flags 的变量中。键入 head(flags) 来预览数据集的前六行。 > head(flags) name landmass zone area population language religion bars stripes colours red green blue gold white black orange 1 Afghanistan 5 1 648 16 10 2 0 3 5 1 1 0 1 1 1 0 2 Albania 3 1 29 3 6 6 0 0 3 1 0 0 1 0 1 0 3 Algeria 4 1 2388 20 8 2 2 0 3 1 1 0 0 1 0 0 4 American-Samoa 6 3 0 0 1 1 0 0 5 1 0 1 1 1 0 1 5 Andorra 3 1 0 0 6 0 3 0 3 1 0 1 1 0 0 0 6 Angola 4 2 1247 7 10 5 0 2 3 1 0 0 1 0 1 0 mainhue circles crosses saltires quarters sunstars crescent triangle icon animate text topleft botright 1 green 0 0 0 0 1 0 0 1 0 0 black green 2 red 0 0 0 0 1 0 0 0 1 0 red red 3 green 0 0 0 0 1 1 0 0 0 0 green white 4 blue 0 0 0 0 0 0 1 1 1 0 blue red 5 gold 0 0 0 0 0 0 0 0 0 0 blue red 6 red 0 0 0 0 1 0 0 1 0 0 red black 您可能需要向上滚动才能看到所有的输出结果。现在，让我们使用 dim(flags) 来检查数据集的维度。 > dim(flags) [1] 194 30 结果告诉我们，有 194 行，或观察值，和 30 列，或变量。每个观察值是一个国家，每个变量描述的是国家或国旗的特征。使用 viewinfo() 可以查看数据集的完整描述。 对于任何数据集，我们都想知道变量是以什么格式存储的。换句话说，每个变量是什么类型的。可以使用 class(flags) 查看。 > class(flags) [1] \"data.frame\" 它告诉我们的是这个数据集是作为数据框存储的，这没有回答我们的问题。我们需要的是对每一列都调用 class() 函数。虽然我们可以手动完成（即一次一列），但是如果我们能自动化这个过程，速度会快得多。听起来像一个循环！ lapply() 函数接收列表作为输入，对列表中的每个元素应用一个函数，然后返回一个与原始列表长度相同的列表。实际上数据框只是向量的列表，所以我们可以使用 lapply() 将 class() 函数应用到 flags 数据集的每一列。我们来看一下它是如何运作的。 键入 cls_list 来对数据集的每一列应用 class() 函数，然后将结果储存在名为 cls_list 的变量里。注意，您只需要提供要应用的函数名称，后面不需要括号。 > cls_list cls_list $name [1] \"factor\" $landmass [1] \"integer\" $zone [1] \"integer\" $area [1] \"integer\" $population [1] \"integer\" $language [1] \"integer\" $religion [1] \"integer\" $bars [1] \"integer\" $stripes [1] \"integer\" $colours [1] \"integer\" $red [1] \"integer\" $green [1] \"integer\" $blue [1] \"integer\" $gold [1] \"integer\" $white [1] \"integer\" $black [1] \"integer\" $orange [1] \"integer\" $mainhue [1] \"factor\" $circles [1] \"integer\" $crosses [1] \"integer\" $saltires [1] \"integer\" $quarters [1] \"integer\" $sunstars [1] \"integer\" $crescent [1] \"integer\" $triangle [1] \"integer\" $icon [1] \"integer\" $animate [1] \"integer\" $text [1] \"integer\" $topleft [1] \"factor\" $botright [1] \"factor\" lapply 中的 l 代表的是 list。键入 class(cls_list) 来确认 lapply() 的输出结果为列表。 > class(cls_list) [1] \"list\" 和意想中的一样，我们得到了一个长度为 30 的列表，每一列或者是每一个变量是一个元素。如果我们可以把它表示成一个向量，而不是一个列表，输出将会更加紧凑。 您可能还记得之前的课程中提到的列表对于存储各个数据类型最有帮助。在这种情况下，由于 lapply() 返回的列表中的每个元素都是长度为 1 的字符向量（即\"整数\"和\"向量\"），所以 cls_list 可以简化为一个字符向量。要手动执行此操作，请键入 as.character(cls_list) > as.character(cls_list) [1] \"factor\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" [13] \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"factor\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" [25] \"integer\" \"integer\" \"integer\" \"integer\" \"factor\" \"factor\" sapply() 允许您通过在幕后调用 lapply() 来自动化这个过程，但是随后尝试为您简化结果（sapply 中的 s ）。使用 sapply() 的方式与使用 lapply() 的方式相同，可以获得标记数据集的每一列的类型，并将结果存储在 cls_vect 中。 > cls_vect cls_vect name landmass zone area population language religion bars stripes colours red \"factor\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" green blue gold white black orange mainhue circles crosses saltires quarters \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"factor\" \"integer\" \"integer\" \"integer\" \"integer\" sunstars crescent triangle icon animate text topleft botright \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"factor\" \"factor\" 键入 class(cls_vect) 来确认 sapply() 返回的是一个字符向量。 > class(cls_vect) [1] \"character\" 通常情况下，如果结果是每个元素都是长度为 1 的列表，使用 sapply() 返回的就是一个向量。如果结果是每个元素都是相同长度(>1)的向量，那么 sapply() 返回的是一个矩阵。如果 sapply() 无法分辨，那么它返回的就是一个列表，和 lapply() 返回的结果并无不同。 让我们再练习 lapply() 和 sapply() ! 数据集的第11-17列是指示变量，每个代表的是一个不同的颜色。如果对应的国家的国旗存在这种颜色，则值为 1，否则为 0。 因此，如果我们想知道数据集中含有某指标的国家数，例如，国旗中包含橘色的国家数，我们可以计算橘色列的所有的 1 和 0 的总和。尝试 sum(flags$orange) 来查看结果。 > sum(flags$orange) [1] 26 现在我们想为数据集中每个记录的颜色都重复此操作。 首先，使用 flag_colors 来提取所有包含颜色的列数据，并存储在名为 flag_colors 的数据框中。（注意，在11:17之前的逗号，它的意思是告诉 R，我们想要所有的行，但是仅需11至17列。） > flag_colors 使用 head() 函数来查看 flag_colors 的前 6 行数据。 > head(flag_colors) red green blue gold white black orange 1 1 1 0 1 1 1 0 2 1 0 0 1 0 1 0 3 1 1 0 0 1 0 0 4 1 0 1 1 1 0 1 5 1 0 1 1 0 0 0 6 1 0 0 1 0 1 0 为了获得一个包含 flag_colors 每一列总和的列表，调用有两个参数的 lapply() 函数。第一个参数是需要执行循环的对象（例 flag_colors），第二个参数是我们希望应用到每一列的函数（例 sum）。记住第二个参数不需要函数名字后面的双括号。 > lapply(flag_colors, sum) $red [1] 153 $green [1] 91 $blue [1] 99 $gold [1] 91 $white [1] 146 $black [1] 52 $orange [1] 26 结果告诉我们，在数据集中的194个国旗中，153个包含了红色，91个包含了绿色，等等。 结果是个列表，因此 lapply() 返回的也是一个列表。这个列表的每个元素都是长度为 1 的列表，所以结果通过调用 sapply() 而不是 lapply() 简化成一个向量。现在试一下。 > sapply(flag_colors, sum) red green blue gold white black orange 153 91 99 91 146 52 26 包含每个颜色的国旗所占的比例，也许是更加重要的信息。因为每一列都是一串 1, 0 数据，每一列的算术平均值就是值为 1 的数据所占的比例。 使用 sapply() 调用 mean() 函数来计算 flag_color 每一列的平均值。记住，第二个参数只列出函数的名字，不加双括号。 > sapply(flag_colors, mean) red green blue gold white black orange 0.7886598 0.4690722 0.5103093 0.4690722 0.7525773 0.2680412 0.1340206 在我们目前看到的示例中，sapply() 已经将结果简化为一个向量。这是因为 lapply() 返回的结果是每个元素都是长度为 1 的向量组成的列表。如果每个元素的长度大于 1，返回的结果应该是个矩阵。 为了阐明这点，让我们提取出数据集的第19-23列，并存储在名为 flag_shapes 的数据框里。flag_shapes 可以完成任务。 > flag_shapes 每一列（例，变量）代表的是某一特定形状或图案出现在一国国旗上的次数。我们对每个形状或图案出现的最大和最小次数感兴趣。 range() 函数可以返回它的第一个参数的最小和最大值，结果应该是一个数字向量。使用 lapply() 对 flag_shapes 调用 range 函数。 > lapply(flag_shapes, range) $circles [1] 0 4 $crosses [1] 0 2 $saltires [1] 0 1 $quarters [1] 0 4 $sunstars [1] 0 50 再执行一次相同的操作，但是要使用 sapply() 函数，并将结果存储为名称是 shape_mat 的变量。 > shape_mat shape_mat circles crosses saltires quarters sunstars [1,] 0 0 0 0 0 [2,] 4 2 1 4 50 使用 class() 函数来确认 shape_mat 是一个矩阵。 > class(shape_mat) [1] \"matrix\" 正如我们看到的，sapply() 总是尝试简化 lapply() 的结果。到目前为止，我们所看到的每个例子都成功做到了这一点。让我们来看一个例子，在这个例子中，sapply() 不知道如何简化结果，因此返回一个列表，这与 lapply() 没有什么不同。 当给出一个向量时，unique() 函数返回一个删除了所有重复元素的向量。换句话说，unique() 只返回 unique 元素的向量。要查看它时如何工作的，可以试试 unique(c(3, 4, 5, 5, 5, 6, 6))。 > unique(c(3, 4, 5, 5, 5, 6, 6)) [1] 3 4 5 6 我们想知道在国旗数据集中的每个变量的唯一值。为此，使用 lapply() 将 unique() 函数应用到国旗数据集中的每一列，并将结果存储在一个名为 unique_vals 的变量中。 > unique_vals unique_vals $name [1] Afghanistan Albania Algeria American-Samoa [5] Andorra Angola Anguilla Antigua-Barbuda [9] Argentina Argentine Australia Austria [13] Bahamas Bahrain Bangladesh Barbados [17] Belgium Belize Benin Bermuda [21] Bhutan Bolivia Botswana Brazil [25] British-Virgin-Isles Brunei Bulgaria Burkina [29] Burma Burundi Cameroon Canada [33] Cape-Verde-Islands Cayman-Islands Central-African-Republic Chad [37] Chile China Colombia Comorro-Islands [41] Congo Cook-Islands Costa-Rica Cuba [45] Cyprus Czechoslovakia Denmark Djibouti [49] Dominica Dominican-Republic Ecuador Egypt [53] El-Salvador Equatorial-Guinea Ethiopia Faeroes [57] Falklands-Malvinas Fiji Finland France [61] French-Guiana French-Polynesia Gabon Gambia [65] Germany-DDR Germany-FRG Ghana Gibraltar [69] Greece Greenland Grenada Guam [73] Guatemala Guinea Guinea-Bissau Guyana [77] Haiti Honduras Hong-Kong Hungary [81] Iceland India Indonesia Iran [85] Iraq Ireland Israel Italy [89] Ivory-Coast Jamaica Japan Jordan [93] Kampuchea Kenya Kiribati Kuwait [97] Laos Lebanon Lesotho Liberia [101] Libya Liechtenstein Luxembourg Malagasy [105] Malawi Malaysia Maldive-Islands Mali [109] Malta Marianas Mauritania Mauritius [113] Mexico Micronesia Monaco Mongolia [117] Montserrat Morocco Mozambique Nauru [121] Nepal Netherlands Netherlands-Antilles New-Zealand [125] Nicaragua Niger Nigeria Niue [129] North-Korea North-Yemen Norway Oman [133] Pakistan Panama Papua-New-Guinea Parguay [137] Peru Philippines Poland Portugal [141] Puerto-Rico Qatar Romania Rwanda [145] San-Marino Sao-Tome Saudi-Arabia Senegal [149] Seychelles Sierra-Leone Singapore Soloman-Islands [153] Somalia South-Africa South-Korea South-Yemen [157] Spain Sri-Lanka St-Helena St-Kitts-Nevis [161] St-Lucia St-Vincent Sudan Surinam [165] Swaziland Sweden Switzerland Syria [169] Taiwan Tanzania Thailand Togo [173] Tonga Trinidad-Tobago Tunisia Turkey [177] Turks-Cocos-Islands Tuvalu UAE Uganda [181] UK Uruguay US-Virgin-Isles USA [185] USSR Vanuatu Vatican-City Venezuela [189] Vietnam Western-Samoa Yugoslavia Zaire [193] Zambia Zimbabwe 194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola Anguilla Antigua-Barbuda Argentina Argentine ... Zimbabwe $landmass [1] 5 3 4 6 1 2 $zone [1] 1 3 2 4 $area [1] 648 29 2388 0 1247 2777 7690 84 19 1 143 31 23 113 47 1099 600 8512 6 111 [21] 274 678 28 474 9976 4 623 1284 757 9561 1139 2 342 51 115 9 128 43 22 49 [41] 284 1001 21 1222 12 18 337 547 91 268 10 108 249 239 132 2176 109 246 36 215 [61] 112 93 103 3268 1904 1648 435 70 301 323 11 372 98 181 583 236 30 1760 3 587 [81] 118 333 1240 1031 1973 1566 447 783 140 41 1267 925 121 195 324 212 804 76 463 407 [101] 1285 300 313 92 237 26 2150 196 72 637 1221 99 288 505 66 2506 63 17 450 185 [121] 945 514 57 5 164 781 245 178 9363 22402 15 912 256 905 753 391 $population [1] 16 3 20 0 7 28 15 8 90 10 1 6 119 9 35 4 24 2 11 1008 5 47 31 54 [25] 17 61 14 684 157 39 57 118 13 77 12 56 18 84 48 36 22 29 38 49 45 231 274 60 $language [1] 10 6 8 1 2 4 3 5 7 9 $religion [1] 2 6 1 0 5 3 4 7 $bars [1] 0 2 3 1 5 $stripes [1] 3 0 2 1 5 9 11 14 4 6 13 7 $colours [1] 5 3 2 8 6 4 7 1 $red [1] 1 0 $green [1] 1 0 $blue [1] 0 1 $gold [1] 1 0 $white [1] 1 0 $black [1] 1 0 $orange [1] 0 1 $mainhue [1] green red blue gold white orange black brown Levels: black blue brown gold green orange red white $circles [1] 0 1 4 2 $crosses [1] 0 1 2 $saltires [1] 0 1 $quarters [1] 0 1 4 $sunstars [1] 1 0 6 22 14 3 4 5 15 10 7 2 9 50 $crescent [1] 0 1 $triangle [1] 0 1 $icon [1] 1 0 $animate [1] 0 1 $text [1] 0 1 $topleft [1] black red green blue white orange gold Levels: black blue gold green orange red white $botright [1] green red white black blue gold orange brown Levels: black blue brown gold green orange red white 因为 unique_vals 是一个列表，你可以使用学到的知识来确定 unique_vals 的每个元素的长度（即每个变量的唯一值的数量）。尽可能简化结果。提示：将 length() 函数应用到 unique_vals 的每个元素中。 > sapply(unique_vals, length) name landmass zone area population language religion bars stripes colours red 194 6 4 136 48 10 8 5 12 8 2 green blue gold white black orange mainhue circles crosses saltires quarters 2 2 2 2 2 2 8 4 3 2 3 sunstars crescent triangle icon animate text topleft botright 14 2 2 2 2 2 7 8 事实上，unique_vals 列表的元素是长度不同的向量，这导致了 sapply() 的一个问题，因为没有明显的方式可以简化结果。 使用 sapply() 应用 unique() 函数到 flags 数据集的每一列，以查看是否得到与 lapply() 相同的未简化列表。 > sapply(flags, unique) $name [1] Afghanistan Albania Algeria American-Samoa [5] Andorra Angola Anguilla Antigua-Barbuda [9] Argentina Argentine Australia Austria [13] Bahamas Bahrain Bangladesh Barbados [17] Belgium Belize Benin Bermuda [21] Bhutan Bolivia Botswana Brazil [25] British-Virgin-Isles Brunei Bulgaria Burkina ... 有时，您可能需要应用一个尚未定义的函数，因此需要编写自己的函数。在 R 中编写函数超出了本课的范围，但是让我们看一个快速的例子。 假设您只对刚刚创建的 unique_vals 列表中每个元素的第二个项目刚兴趣。因为 unique_vals 列表中的每个元素都是一个向量，我们不知道 R 中是否有内置函数返回向量的第二个元素，所以我们将构件自己的函数。 lapply(unique_vals, function(elem) elem[2]) 将返回一个包含 unique_vals 列表每个元素第二项目的列表。记住，我们的函数只包含一个参数 elem，这是一个匿名函数，依次取 unique_vals 的每个元素的值。 > lapply(unique_vals, function(elem) elem[2]) $name [1] Albania 194 Levels: Afghanistan Albania Algeria American-Samoa Andorra Angola Anguilla Antigua-Barbuda Argentina Argentine ... Zimbabwe $landmass [1] 3 $zone [1] 3 $area [1] 29 $population [1] 3 $language [1] 6 $religion [1] 6 $bars [1] 2 $stripes [1] 0 $colours [1] 3 $red [1] 0 $green [1] 0 $blue [1] 1 $gold [1] 0 $white [1] 0 $black [1] 0 $orange [1] 1 $mainhue [1] red Levels: black blue brown gold green orange red white $circles [1] 1 $crosses [1] 1 $saltires [1] 1 $quarters [1] 1 $sunstars [1] 0 $crescent [1] 1 $triangle [1] 1 $icon [1] 0 $animate [1] 1 $text [1] 1 $topleft [1] red Levels: black blue gold green orange red white $botright [1] red Levels: black blue brown gold green orange red white 前面的示例和这个示例之间的唯一区别是，我们在调用 lapply() 时定义并使用了自己的函数。我们的函数没有名称，一旦 lapply() 使用完毕，他就会消失。当 R 的某个内置函数不可用时，所谓的匿名函数就会非常有用。 在本课中，您学习了如何使用强大的 lapply() 和 sapply() 函数对列表的元素进行操作。下一节课，我们将了解它们的一些近亲函数。 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 15:56:20 "},"R/RProgramming/lesson11.html":{"url":"R/RProgramming/lesson11.html","title":"vapply 和 tapply 函数","keywords":"","body":"Lesson 11: vapply 和 tapply 本课内容总结 vapply() 明确指定了 sapply() 结果的格式，可以作为 sapply() 的更安全的替代函数，这在编写自己的函数时非常有用。 tapply() 根据某个变量的值将数据划分为多个组，然后对每个组应用一个函数。 本课详细内容 在上一课中，您学习了 R 的 apply 函数家族中两个最基本的成员：lapply() 和 sapply() 。两者都以一个列表作为输入，对列表中的每个元素应用一个函数，然后返回结果。lapply() 总是返回一个列表，而 sapply() 则试图简化结果。 本节课，您将学习如何使用 vapply() 和 tapply()，它们在 Split-Apply-Combine 方法中都有特定的用途。为了一致性，我们将使用与 lapply() 和 sapply() 课程中相同的数据集。 来自 UCI 机器学习存储库的国旗数据集包含各个国家及其国旗的详细信息。更多信息参见： http://archive.ics.uci.edu/ml/datasets/Flags 我将数据存储在一个名为 flags 的变量中。如果已经有一段时间没有学习 lapply 和 sapply 了，您可能想使用 dim()、head()、str() 和 summary() 等函数来重新熟悉数据。让我们开始吧。 正如您在上一课中看到的，unique() 函数返回传递给它的对象中包含的唯一值的向量。因此，sapply(flags, unique) 返回一个列表，其中包含标示数据集的每一列的唯一值向量。现在再试一次。 > sapply(flags, unique) $name [1] Afghanistan Albania Algeria American-Samoa [5] Andorra Angola Anguilla Antigua-Barbuda [9] Argentina Argentine Australia Austria [13] Bahamas Bahrain Bangladesh Barbados [17] Belgium Belize Benin Bermuda [21] Bhutan Bolivia Botswana Brazil [25] British-Virgin-Isles Brunei Bulgaria Burkina [29] Burma Burundi Cameroon Canada [33] Cape-Verde-Islands Cayman-Islands Central-African-Republic Chad [37] Chile China Colombia Comorro-Islands [41] Congo Cook-Islands Costa-Rica Cuba [45] Cyprus Czechoslovakia Denmark Djibouti [49] Dominica Dominican-Republic Ecuador Egypt ... sapply() 可以尝试简化 lapply() 的结果，当以交互方式工作时，这并不是什么大问题，因为您可以立即看到结果并很快地认识到自己的错误。然而，在非交互的情况下（例如，编写自己的函数），错误可能不会被发现，并在以后导致不正确的结果。因为，您可能希望更加小心，这就是 vapply() 的用处所在。 sapply() 尝试 猜测 结果的正确格式，而 vapply() 允许您明确地指定它。如果结果与您指定的格式不匹配，vapply() 将抛出一个错误，导致操作停止。这可以防止由于从 sapply() 获取意外的返回值而导致的代码中的重大问题。 尝试 vapply(flags, unique, numeric(1))，它表示您希望结果的每个元素都是长度为 1 的数字向量。由于实际情况并非如此，您将得到一个错误。得到错误后，输入 ok() 继续下一个问题。 > vapply(flags, unique, numberic(1)) Error in numberic(1) : could not find function \"numberic\" > ok() 回想前面的课程，sapply(flags, class) 将返回一个字符向量，其中包含数据集中每一列的类。现在再试一次，看看结果。 > sapply(flags, class) name landmass zone area population language religion bars stripes colours red \"factor\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" green blue gold white black orange mainhue circles crosses saltires quarters \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"factor\" \"integer\" \"integer\" \"integer\" \"integer\" sunstars crescent triangle icon animate text topleft botright \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"factor\" \"factor\" 如果我们希望明确我们期望的结果的格式，我们可以使用 vapply(flags, class, character(1))。character(1) 参数告诉 R，我们期望 class 函数在应用到标记数据集的每一列时返回长度为 1 的字符向量。现在试一试。 > vapply(flags, class, character(1)) name landmass zone area population language religion bars stripes colours red \"factor\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" green blue gold white black orange mainhue circles crosses saltires quarters \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"factor\" \"integer\" \"integer\" \"integer\" \"integer\" sunstars crescent triangle icon animate text topleft botright \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"integer\" \"factor\" \"factor\" 注意，由于我们的期望是正确的(即 character(1))，所以 vapply() 结果与 sapply() 结果相同——sapply() 结果是列 class 的字符向量。 您可能认为 vapply() 比 sapply() 更 安全，因为它要求您预先指定输出的格式，而不是让 R 来 猜测 您想要的格式。此外，对于大型数据集，vapply() 可能比 sapply() 执行得更快。然而，当交互地(命令行)进行数据分析时，sapply() 可以节省一些输入，而且通常已经足够了。 作为一名数据分析师，您通常希望根据某个变量的值将数据分成多个组，然后将一个函数应用于每个组的成员。我们将看到的下一个函数 tapply() 正是这样做的。 使用 ?tapply 调出文档。 数据集中的 landmass 变量取 1 到 6 之间的整数值，每个整数值代表世界的不同部分。使用 table(flags$landmass) 查看每个部分有多少个国旗或国家。 > table(flags$landmass) 1 2 3 4 5 6 31 17 35 52 39 20 如果一个国家的国旗包含有动画图像(如鹰、树、人手)，则数据集中的 animate 变量的值为 1，否则为 0。使用 table(flags$animate) 查看有多少个旗帜包含动画图像。 > table(flags$animate) 0 1 155 39 结果告诉我们，39 个国旗包含一个 animate 对象，而 155 个国旗不包含 animate 对象。 如果你计算一堆 0 和 1 的算术平均值，你会得到数字 1 所占的比例。使用 tapply(flags$animate, flags$landmass, mean) 将平均值函数分别应用于 6 个 landmass 组中的每个 animate 变量，从而给出每个 landmass 组中包含动画图像的国旗的比例。 > tapply(flags$animate, flags$landmass, mean) 1 2 3 4 5 6 0.4193548 0.1764706 0.1142857 0.1346154 0.1538462 0.3000000 第一个 landmass 组(landmass = 1)对应于北美，它包含了国旗中，动画图像最高的比例(0.4194)。 类似地，我们可以查看 tapply(flags$population, flags$red, summary) 中包含或不包含国旗为红色的国家的人口数量的总和(以百万为单位)。 > tapply(flags$population, flags$red, summary) $`0` Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 0.00 3.00 27.63 9.00 684.00 $`1` Min. 1st Qu. Median Mean 3rd Qu. Max. 0.0 0.0 4.0 22.1 15.0 1008.0 | What is the median population (in millions) for countries *without* the color red on their flag? 1: 3.0 2: 22.1 3: 0.0 4: 27.6 5: 4.0 6: 9.0 Selection: 1 最后，使用相同的方法来查看六个大陆中每个大陆的人口数量的概况。 > tapply(flags$population, flags$landmass, summary) $`1` Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 0.00 0.00 12.29 4.50 231.00 $`2` Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 1.00 6.00 15.71 15.00 119.00 $`3` Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 0.00 8.00 13.86 16.00 61.00 $`4` Min. 1st Qu. Median Mean 3rd Qu. Max. 0.000 1.000 5.000 8.788 9.750 56.000 $`5` Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 2.00 10.00 69.18 39.00 1008.00 $`6` Min. 1st Qu. Median Mean 3rd Qu. Max. 0.00 0.00 0.00 11.30 1.25 157.00 | What is the maximum population (in millions) for the fourth landmass group (Africa)? 1: 157.00 2: 56.00 3: 1010.0 4: 5.00 5: 119.0 Selection: 2 本节课中，您学习了如何使用 vapply() 作为 sapply() 的更安全的替代方法，这在编写自己的函数时非常有用。您还学习了如何使用 tapply() 根据某个变量的值将数据划分为多个组，然后对每个组应用一个函数。这些功能将为您成为更好的数据分析师提供便利。 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 15:56:20 "},"R/RProgramming/lesson12.html":{"url":"R/RProgramming/lesson12.html","title":"查看数据","keywords":"","body":"Lesson 12: 查看数据 本课总结 本课学习了一些查看数据的函数。 class() 查看类别。 dim() 查看维度。 nrow() 和 ncol() 来查看行数和列数。 object.size() 查看数据集占用多大空间。 names() 返回列名称（变量）。 head() 和 tail() 预览头部或底部数据，可以加第二个参数。 summary() 查看数据的简单概述。 最有用和最简洁的函数可能是 str()。 本课详细内容 无论何时使用新数据集，首先要做的就是查看它！数据的格式是什么？维度是什么？变量的名称是什么？变量是如何存储的？是否存在缺失值？是否存在缺陷？ 本节课将叫你如何回答这些问题，并更多地使用 R 的内置函数。我们将使用美国农业部的植物数据库 (http://plants.usda.gov/adv_search.html)。 我们已经将数据存储在一个名为 plants 的变量中。键入 ls() 来列出工作空间中的变量，其中应该包括 plants。 > ls() [1] \"flags\" \"ok\" \"plants\" \"viewinfo\" 我们首先使用 class(plants) 检查 plants 的类别。这将为我们提供有关数据总体结构的线索。 > class(plants) [1] \"data.frame\" 在数据框中存储数据是很常见的。它是使用 read.csv() 和 read.table() 等函数将数据读入 R 的默认类，您将在另一节课中了解这些函数。 由于数据集存储在数据框中，因此我们知道它是矩形的。换句话说，它有两个维度（行和列），可以方便地放入表或电子表格中。使用 dim(plants) 来查看我们正在处理的行和列的确切数量。 > dim(plants) [1] 5166 10 您看到的第一个数字（5166）是行数（观察值），第二个数字（10）是列数（变量）。 您还可以使用 nrow(plants) 来仅查看行数。使用 ncol(plants) 来仅查看列数。试一下。 > nrow(plants) [1] 5166 > ncol(plants) [1] 10 如果您想知道数据集在内存中占用了多少空间，可以使用 object.size(plants)。 > object.size(plants) 580840 bytes 现在，我们已经了解了数据集的形状和大小，让我们来了解一下其中的内容。names(plants) 将返回一个列（即变量）名称的字符向量。试一试吧。 > names(plants) [1] \"Scientific_Name\" \"Duration\" \"Active_Growth_Period\" \"Foliage_Color\" \"pH_Min\" [6] \"pH_Max\" \"Precip_Min\" \"Precip_Max\" \"Shade_Tolerance\" \"Temp_Min_F\" 我们已经对这个数据集应用了相当多描述性的变量名，但情况并不全是这样的。逻辑上说，我们的下一步是查看实际数据。然而，我们的数据集包含了超过 5000 个观察值（行），因此一次查看全部内容是不现实的。 head() 函数的作用是预览数据集的顶部数据。用一个参数试一下。 > head(plants) Scientific_Name Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min Precip_Max 1 Abelmoschus NA NA NA NA 2 Abelmoschus esculentus Annual, Perennial NA NA NA NA 3 Abies NA NA NA NA 4 Abies balsamea Perennial Spring and Summer Green 4 6 13 60 5 Abies balsamea var. balsamea Perennial NA NA NA NA 6 Abutilon NA NA NA NA Shade_Tolerance Temp_Min_F 1 NA 2 NA 3 NA 4 Tolerant -43 5 NA 6 NA 花一分钟浏览并理解上面的输出。每一行都以观察号做为标记，每一列都用变量名作为标记。您的屏幕垦鞥不够宽，无法并排查看全部 10 列，在这种情况下，R 在每一行上显示尽可能多的列，然后再继续下一行。 默认情况下，head() 显示数据的前六行。您可以通过将希望查看的行数作为第二个参数传递来更改此行为。使用 head() 预览前 10 行 plants. > head(plants, 10) Scientific_Name Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min Precip_Max 1 Abelmoschus NA NA NA NA 2 Abelmoschus esculentus Annual, Perennial NA NA NA NA 3 Abies NA NA NA NA 4 Abies balsamea Perennial Spring and Summer Green 4 6.0 13 60 5 Abies balsamea var. balsamea Perennial NA NA NA NA 6 Abutilon NA NA NA NA 7 Abutilon theophrasti Annual NA NA NA NA 8 Acacia NA NA NA NA 9 Acacia constricta Perennial Spring and Summer Green 7 8.5 4 20 10 Acacia constricta var. constricta Perennial NA NA NA NA Shade_Tolerance Temp_Min_F 1 NA 2 NA 3 NA 4 Tolerant -43 5 NA 6 NA 7 NA 8 NA 9 Intolerant -13 10 NA 同样的，使用 tail() 来预览数据集的结尾部分。使用 tail() 预览最后 15 行。 > tail(plants, 15) Scientific_Name Duration Active_Growth_Period Foliage_Color pH_Min pH_Max Precip_Min Precip_Max 5152 Zizania NA NA NA NA 5153 Zizania aquatica Annual Spring Green 6.4 7.4 30 50 5154 Zizania aquatica var. aquatica Annual NA NA NA NA 5155 Zizania palustris Annual NA NA NA NA 5156 Zizania palustris var. palustris Annual NA NA NA NA 5157 Zizaniopsis NA NA NA NA 5158 Zizaniopsis miliacea Perennial Spring and Summer Green 4.3 9.0 35 70 5159 Zizia NA NA NA NA 5160 Zizia aptera Perennial NA NA NA NA 5161 Zizia aurea Perennial NA NA NA NA 5162 Zizia trifoliata Perennial NA NA NA NA 5163 Zostera NA NA NA NA 5164 Zostera marina Perennial NA NA NA NA 5165 Zoysia NA NA NA NA 5166 Zoysia japonica Perennial NA NA NA NA Shade_Tolerance Temp_Min_F 5152 NA 5153 Intolerant 32 5154 NA 5155 NA 5156 NA 5157 NA 5158 Intolerant 12 5159 NA 5160 NA 5161 NA 5162 NA 5163 NA 5164 NA 5165 NA 5166 NA 在预览了数据的顶部和底部之后，您可能注意到存在许多的 NA，它们是 R 中缺失值的占位符。使用 summary(plants) 可以更好地了解每个变量是如何分布的，以及数据集缺失了多少。 > summary(plants) Scientific_Name Duration Active_Growth_Period Foliage_Color Abelmoschus : 1 Perennial :3031 Spring and Summer : 447 Dark Green : 82 Abelmoschus esculentus : 1 Annual : 682 Spring : 144 Gray-Green : 25 Abies : 1 Annual, Perennial: 179 Spring, Summer, Fall: 95 Green : 692 Abies balsamea : 1 Annual, Biennial : 95 Summer : 92 Red : 4 Abies balsamea var. balsamea: 1 Biennial : 57 Summer and Fall : 24 White-Gray : 9 Abutilon : 1 (Other) : 92 (Other) : 30 Yellow-Green: 20 (Other) :5160 NA's :1030 NA's :4334 NA's :4334 pH_Min pH_Max Precip_Min Precip_Max Shade_Tolerance Temp_Min_F Min. :3.000 Min. : 5.100 Min. : 4.00 Min. : 16.00 Intermediate: 242 Min. :-79.00 1st Qu.:4.500 1st Qu.: 7.000 1st Qu.:16.75 1st Qu.: 55.00 Intolerant : 349 1st Qu.:-38.00 Median :5.000 Median : 7.300 Median :28.00 Median : 60.00 Tolerant : 246 Median :-33.00 Mean :4.997 Mean : 7.344 Mean :25.57 Mean : 58.73 NA's :4329 Mean :-22.53 3rd Qu.:5.500 3rd Qu.: 7.800 3rd Qu.:32.00 3rd Qu.: 60.00 3rd Qu.:-18.00 Max. :7.000 Max. :10.000 Max. :60.00 Max. :200.00 Max. : 52.00 NA's :4327 NA's :4327 NA's :4338 NA's :4338 NA's :4328 summary() 为每个变量提供不同的输出，具体取决于其类别。对于 Precip_Min 等数字数据，summary() 展示最小值，第 1 四分位数，中位数，平均值，第 3 四分位数和最大数。这些值帮助我们理解数据是如何分布的。 对于分类变量（在 R 中称为 因子(factor) 变量），summary() 显示数据中每个值（或 水平 (level)）出现的次数。例如，Scientific Name 的每个值只出现一次，因为它是特定植物所特有的。相反，Duration 概述（也是一个因子变量）告诉我们，我们的数据集包含 3031 个多年生植物，682 个一年生植物，等等。 您可以看到，R 通过包含一个名为 Other 的包罗万象的类别截断了 Active_Growth_Period 的概述。由于它是一个分类/分子变量，我们可以使用 table(plants$Active_Growth_Period) 来查看每个值的实际出现次数。 > table(plants$Active_Growth_Period) Fall, Winter and Spring Spring Spring and Fall Spring and Summer Spring, Summer, Fall 15 144 10 447 95 Summer Summer and Fall Year Round 92 24 5 到目前为止，我们介绍的每个函数都有助于您更好地理解数据的结构。然而，我们把最好的留到了最后。 对于理解数据的结构，最有用和最简洁的函数可能是 str() （structure）。现在就试试吧。 > str(plants) 'data.frame': 5166 obs. of 10 variables: $ Scientific_Name : Factor w/ 5166 levels \"Abelmoschus\",..: 1 2 3 4 5 6 7 8 9 10 ... $ Duration : Factor w/ 8 levels \"Annual\", \"Annual, Biennial\",..: NA 4 NA 7 7 NA 1 NA 7 7 ... $ Active_Growth_Period: Factor w/ 8 levels \"Fall, Winter and Spring\",..: NA NA NA 4 NA NA NA NA 4 NA ... $ Foliage_Color : Factor w/ 6 levels \"Dark Green\", \"Gray-Green\",..: NA NA NA 3 NA NA NA NA 3 NA ... $ pH_Min : num NA NA NA 4 NA NA NA NA 7 NA ... $ pH_Max : num NA NA NA 6 NA NA NA NA 8.5 NA ... $ Precip_Min : int NA NA NA 13 NA NA NA NA 4 NA ... $ Precip_Max : int NA NA NA 60 NA NA NA NA 20 NA ... $ Shade_Tolerance : Factor w/ 3 levels \"Intermediate\",..: NA NA NA 3 NA NA NA NA 2 NA ... $ Temp_Min_F : int NA NA NA -43 NA NA NA NA -13 NA ... str() 的美妙之处在于，它结合了您已经看到的其他函数的许多特性，所有这些特性都以简洁和可读的格式呈现。在最上面，它告诉我们 plants 的类别是 data.frame，它有 5166 个观测值和 10 个变量。然后，它给出每个变量的名称和类别。以及其内容的预览。 str() 实际上是一个非常通用的函数，您可以在 R 中对大多数对象使用它。任何时候，如果您想要了解某个对象的结构（数据集、函数等），str() 都是一个很好的开始。 在本课中，您学习了如何使用一组简单而有用的函数来感受新数据集的结构和内容。提前花点时间做这件事可以节省您的时间，并在以后的分析中减少您的挫败感。 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 15:56:20 "},"R/RProgramming/lesson13.html":{"url":"R/RProgramming/lesson13.html","title":"随机模拟","keywords":"","body":"Lesson 13: 随机模拟 本课总结 本课学习了一些生成随机数的函数。 sample() 函数，replace 参数默认为 FALSE，意思是不放回取样，如果设为 TRUE，意思则为放回取样。 LETTERS 是 R 中一个预定义的变量，包含所有 26 个英文字母的向量。 rbinom() 是二项式随机行数，用法例 rbinom(1, size = 100, prob = 0.7) 。 rnorm(10, mean = 100, sd = 25) 正态分布，默认平均值为 0，标准差为 1。 rpois(5, lambda = 10) 泊松分布，生成 5 数字，符合均值为 10 的泊松分布。 my_pois ，上述操作执行 100 次，生成一个矩阵。 cm ，计算上述矩阵的列平均值。 hist(cm) 查看其分布。 本课详细内容 使用像 R 这样的统计编程语言的一大优点是它有大量的工具来模拟随机数。 本课程假设您熟悉一些常见的概率分布，但这些课题只会在随机数生成方面进行讨论。即使你之前没有这些概念的经验，你也应该能够完成课程并理解主要思想。 我们用来生成随机数的第一个函数是 sample()。使用 ?sample 来调出文档。 让我们来模拟滚动四个六边形的骰子: sample(1:6, 4, replace = TRUE)。 > sample(1:6, 4, replace = TRUE) [1] 1 2 3 4 现在重复该命令，看看结果有何不同。（结果完全相同的概率是 (1/6)的 4 次方，这非常小！） > sample(1:6, 4, replace = TRUE) [1] 6 4 4 4 sample(1:6, 4, replace = TRUE) 指示 R 随机选择 1 到 6 之间的四个数字，并可以重复（有放回抽样）。replace 参数的意思是每个数字都是可以重复出现的，因此相同的数字可以出现不止一次，这就是我们想要的，因为您在一个骰子上滚动的结果不会影响您在其他骰子上滚动的结果。 现在在 1 到 20 之间采样 10 个数字，数字不可重复出现。要进行不重复出现的抽样，只需去掉 replace 参数。 > sample(1:20, 10) [1] 10 18 1 16 3 5 4 17 7 8 由于最后一个命令在没有 replace 参数的情况下采样，所以输出结果中不会出现重复的数字。 LETTERS 是 R 中一个预定义的变量，包含所有 26 个英文字母的向量。现在就来看看吧。 > LETTERS [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\" 还可以使用 sample() 函数对向量的元素进行置换或重新排列。例如，尝试 sample(LETTERS) 来排列英语字母表中的所有的 26 个字母。 > sample(LETTERS) [1] \"Z\" \"Y\" \"X\" \"D\" \"O\" \"S\" \"V\" \"E\" \"I\" \"W\" \"U\" \"G\" \"B\" \"C\" \"L\" \"K\" \"R\" \"F\" \"T\" \"M\" \"Q\" \"J\" \"H\" \"P\" \"N\" \"A\" 这和从 LETTERS 中抽取 26 个样本是一样的，不可重复出现。当没有指定 sample() 的 size 参数时，R 取一个与您采样的向量大小相同的样本你。 现在，假设我们想要模拟抛 100 次不均匀的两面正面硬币。这个特定的硬币有 0.3 的概率落反面，和 0.7 的概率落正面。 设 0 代表反面，1 代表正面。使用 sample() 从向量 c(0, 1) 中绘制大小为 100 的样本，并可重复出现。因为这枚硬币是不公平的，我们需要第四个参数 prob = c(0.3, 0.7) 来为 0 和 1 赋予特定的概率。将结果分配给一个名为 flips 的新变量，并查看其内容。 > flips flips [1] 1 1 1 1 1 1 1 1 1 0 1 1 0 0 0 1 1 1 0 0 1 0 0 1 1 1 1 1 0 0 1 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 0 0 1 1 1 1 0 1 1 1 0 0 1 1 1 [62] 0 1 1 1 0 1 1 0 1 0 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1 0 0 0 1 由于我们将每次抛硬币出现正面的概率设为 0.7，所以我们预计大约有 70 次抛硬币的结果都是 1。使用 sum() 函数计算抛掷中包含的 1 的实际数目。 > sum(flips) [1] 69 抛硬币是一个二进制结果（0 或 1），我们执行 100 次独立实验（抛硬币），所以我们可以使用 rbinom() 来模拟一个二项随机变量。使用 ?rbinom 调出文档。 R 中的每个概率分布都有一个对应的 r*** 函数（意思是 随机 random），一个 d*** 函数（密度 density），一个 p*** 函数（概率 probability）以及一个 q*** 函数（分位数 quantile）。我们最感兴趣的是本课中 r*** 函数，但我鼓励您自己取探索其他函数。 二项随机变量表示在给定数目的独立试验（抛硬币）中成功（正面）的数目。因此，我们可以使用 rbinom(1, size = 100, prob = 0.7) 生成一个随机变量，它表示非均匀硬币 1001 次抛投中正面的数量。注意，您只需指定成功（正面）的概率，而不需指定失败（反面）的概率。现在试一试。 > rbinom(1, size = 100, pro = 0.7) [1] 78 同样地，如果我们像看到所以的 0 和 1，我们可以请求 100 个观测值，每个大小为 1，成功的概率为 0.7。尝试一下，将结果分配给一个名为 flips2 的新变量。 > flips2 flips2 [1] 1 0 0 1 1 0 0 1 1 1 1 0 0 1 1 1 1 0 0 0 1 1 0 1 1 0 0 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 [62] 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 1 1 0 0 1 1 1 1 1 0 0 1 1 1 0 1 1 0 0 1 0 1 1 1 现在使用 sum() 函数来计算数字 1 出现的次数。它应该很接近 70！ > sum(flips2) [1] 71 与 rbinom() 类似，我们可以使用 R 来模拟许多其他概率分布中的随机数。现在打开 rnorm() 的文档。 这是一个均值为 0，标准差为 1 的正态分布。正如您在文档的 Usage 一节中看到的，rnorm() 的 mean 和 sd 参数默认值分别是 0 和 1。因此，rnorm(10) 将从一个标准正态分布中产生 10 个随机数。试试吧。 > rnorm(10) [1] -1.128544239 -0.582242837 0.006230103 -0.621767254 0.819396336 -2.043350180 -2.085213991 1.865582828 -0.817865961 [10] -1.482506499 现在再做一次同样的事情，只不过平均值是 100，标准差是 25。 > rnorm(10, mean = 100, sd = 25) [1] 80.26535 112.38797 97.91502 78.87868 87.42145 122.99880 86.33341 178.35885 134.10795 93.46554 最后，如果我们想要模拟 100 组的随机数，每组包含 5 个由均值为 10 的泊松分布产生的值，我们从一组 5 个数字开始，然后我将向您展示如何以一种方便而紧凑的方式重复 100 次操作。 从均值为 10 的泊松分布中生成 5 个随机值。如果需要帮助，请参阅 rpois() 的文档。 > rpois(5, lambda = 10) [1] 5 11 7 9 10 现在使用 replicate(100, rpois(5, 10)) 来执行这个操作 100 次。将结果存储再一个名为 my_pois 的新变量里，并查看其内容。 > my_pois my_pois [, 1] [, 2] [, 3] [, 4] [, 5] [, 6] [, 7] [, 8] [, 9] [, 10] [, 11] [, 12] [, 13] [, 14] [, 15] [, 16] [, 17] [, 18] [, 19] [, 20] [, 21] [1,] 15 12 9 7 8 8 7 7 6 17 16 8 12 8 9 11 11 6 7 12 6 [2,] 8 7 6 9 10 4 13 10 5 7 10 6 14 9 15 7 6 14 12 6 6 [3,] 10 6 6 10 11 10 7 8 9 15 8 7 11 13 3 8 5 12 10 9 3 [4,] 13 11 10 7 8 10 10 7 6 9 13 17 11 4 5 10 9 12 8 9 8 [5,] 9 10 10 11 15 7 2 10 13 8 6 6 7 13 13 4 9 13 9 12 12 [, 22] [, 23] [, 24] [, 25] [, 26] [, 27] [, 28] [, 29] [, 30] [, 31] [, 32] [, 33] [, 34] [, 35] [, 36] [, 37] [, 38] [, 39] [, 40] [, 41] [1,] 11 4 6 10 9 5 9 9 7 14 16 6 12 6 9 8 10 10 11 7 [2,] 9 10 13 8 8 19 9 4 17 9 12 8 7 8 9 7 6 11 7 10 [3,] 12 12 13 12 7 11 12 9 10 12 16 7 6 11 10 10 8 11 10 14 [4,] 16 11 9 12 18 8 10 8 9 6 8 9 7 11 13 11 6 8 12 16 [5,] 9 11 12 14 10 12 15 11 9 10 11 5 13 9 13 9 9 9 7 9 [, 42] [, 43] [, 44] [, 45] [, 46] [, 47] [, 48] [, 49] [, 50] [, 51] [, 52] [, 53] [, 54] [, 55] [, 56] [, 57] [, 58] [, 59] [, 60] [, 61] [1,] 10 9 9 8 8 13 7 5 11 8 12 10 9 10 18 10 8 7 12 11 [2,] 9 16 13 8 9 16 3 10 11 12 12 9 9 11 8 10 15 12 9 13 [3,] 10 3 15 11 15 11 15 19 8 10 11 13 8 8 10 11 8 6 11 10 [4,] 10 9 9 9 9 17 10 7 9 9 14 14 6 9 7 10 12 12 10 5 [5,] 13 10 8 8 10 8 12 12 11 5 9 9 8 12 9 8 7 12 10 10 [, 62] [, 63] [, 64] [, 65] [, 66] [, 67] [, 68] [, 69] [, 70] [, 71] [, 72] [, 73] [, 74] [, 75] [, 76] [, 77] [, 78] [, 79] [, 80] [, 81] [1,] 8 15 10 10 11 6 11 7 7 8 11 13 10 6 4 13 6 7 12 7 [2,] 15 5 16 5 6 11 8 6 15 11 11 11 4 4 11 9 6 5 13 12 [3,] 7 6 6 8 7 11 11 5 4 12 7 10 5 8 19 12 16 4 11 7 [4,] 7 12 7 10 3 9 8 11 6 5 9 13 12 9 11 11 8 7 7 10 [5,] 10 9 24 11 4 6 8 11 8 15 9 14 8 12 8 11 9 14 9 9 [, 82] [, 83] [, 84] [, 85] [, 86] [, 87] [, 88] [, 89] [, 90] [, 91] [, 92] [, 93] [, 94] [, 95] [, 96] [, 97] [, 98] [, 99] [, 100] [1,] 7 10 13 5 16 12 13 11 14 12 7 15 8 10 3 5 9 12 12 [2,] 11 7 15 11 13 12 14 11 4 16 7 8 14 8 4 9 9 11 14 [3,] 13 8 12 9 10 12 7 13 8 10 5 7 8 10 10 15 13 9 8 [4,] 6 11 13 11 5 8 6 13 9 9 8 13 19 14 10 11 11 7 7 [5,] 8 9 6 8 9 13 9 8 6 11 10 8 11 6 7 10 11 6 11 replicate() 函数创建了一个矩阵，该矩阵的每一列均包含 5 个随机值，这些随机值是根据 Poisson 分布生成的，且均值为 10。现在，我们可以使用 colMeans() 函数再 my_pois 中找到每一列的平均值。将结果存储再一个名为 cm 的变量中。 > cm cm [1] 11.0 9.2 8.2 8.8 10.4 7.8 7.8 8.4 7.8 11.2 10.6 8.8 11.0 9.4 9.0 8.0 8.0 11.4 9.2 9.6 7.0 11.4 9.6 10.6 [25] 11.2 10.4 11.0 11.0 8.2 10.4 10.2 12.6 7.0 9.0 9.0 10.8 9.0 7.8 9.8 9.4 11.2 10.4 9.4 10.8 8.8 10.2 13.0 9.4 [49] 10.6 10.0 8.8 11.6 11.0 8.0 10.0 10.4 9.8 10.0 9.8 10.4 9.8 9.4 9.4 12.6 8.8 6.2 8.6 9.2 8.0 8.0 10.2 9.4 [73] 12.2 7.8 7.8 10.6 11.2 9.0 7.4 10.4 9.0 9.0 9.0 11.8 8.8 10.6 11.4 9.8 11.2 8.2 11.6 7.4 10.2 12.0 9.6 6.8 [97] 10.0 10.6 9.0 10.4 让我们通过使用 hist(cm) 绘制直方图来看一下列的分布。 看起来我们的列均值几乎是正态分布的，对吧这就是中心极限定理，不过这是以后的内容了。 所有的标准概率分布都内置于 R 中，包括指数分布(rexp())，卡方分布(rchisq())， 伽玛分布(rgamma())，…你看到规律了吧。 随机数实际上是一个独立的领域，我们只是触及了它的表面。我鼓励您自己进一步探索这些功能和其他功能。 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 15:56:20 "},"R/RProgramming/lesson14.html":{"url":"R/RProgramming/lesson14.html","title":"日期和时间","keywords":"","body":"Lesson 14: 日期和时间 本课总结 日期和时间可分为 POSIXct 和 POSIXlt 两大类。 class() 可查看其类别，unclass() 查看其内部情况。 Sys.time() 返回的是类别为 POSIXct 的对象，但是我们可以使用 as.POSIXlt(Sys.time()) 将结果强制转换为 POSIXlt。 POSIXlt 对象是个列表。 可以对时间和日期执行算术运算和比较运算。 您可以使用 difftime() 函数，它允许您指定一个 单位 参数。例 difftime(Sys.time(), t1, units = 'days') 。 本课详细内容 R 有一种特殊的表示日期和时间的方法，如果您处理的数据展示了某件事情是如何随时间变化的（即时间序列数据），或者您的数据包含一些其他的时间信息，比如出生日期，那么这种方法就很有帮助。 日期属于 Date 类别，时间分为 POSIXct 和 POSIXlt 类别。在运算的内部，日期存储为 1970-01-01 之后的天数，时间存储为 1970-01-01 之后的秒数（对于 POSIXct 来说）或秒、分钟、小时等列表（对于 POSIXlt）。 我们首先使用 d1 来获取当前日期并将其存储在变量 d1 中。 > d1 使用 class() 变量来确认 d1 是一个时间对象。 > class(d1) [1] \"Date\" 我们可以使用 unclass() 函数来查看 d1 的内部情况。试一下。 > unclass(d1) [1] 18350 这是从 1970-01-01 开始的确切天数！ 但是，如果您将 d1 打印到控制台，您将得到今天的日期，以 年-月-日 的方式展示。试试吧。 > d1 [1] \"2020-03-29\" 如果我们需要引用一个 1970-01-01 之前的日期，请创建一个变量 d2，包含 as.Date(\"1969-01-01\")。 > d2 现在再次使用 unclass() 函数来查看在内部 d2 看起来时什么样的。 > unclass(d2) [1] -365 正如您所预料的，您得到了一个负数。在本例中，它是 -365，因为 1969-01-01 正好时 1970-01-01 之前的一个日历年（即 365 天）。 现在，让我们看看 R 是如何存储时间的。可以使用不带参数的 Sys.time() 函数访问当前日期和时间。并将结果存储在一个名为 t1 的变量中，并查看内容和类别。 > t1 t1 [1] \"2020-03-29 08:48:08 UTC\" > class(t1) [1] \"POSIXct\" \"POSIXt\" 如前所述，POSIXct 只是 R 表示时间信息的两种方式之一。您可以忽略上面的第二个值 POSIXt，它只是 POSIXct 和 POSIXlt 之间的一种通用语言。使用 unclass() 查看 t1 的内部情况，自 1970 年初以来的秒数。 > unclass(t1) [1] 1585471689 默认情况下，Sys.time() 返回的是类别为 POSIXct 的对象，但是我们可以使用 as.POSIXlt(Sys.time()) 将结果强制转换为 POSIXlt。试一试，将结果存储在 t2 中。并查看其类别和内容。 > class(t2) [1] \"POSIXlt\" \"POSIXt\" > t2 [1] \"2020-03-29 08:58:30 UTC\" t2 的输出格式与 t1 相同。现在试试 unclass(t2) ，看看它内部有什么不同。 > unclass(t2) $sec [1] 30.97262 $min [1] 58 $hour [1] 8 $mday [1] 29 $mon [1] 2 $year [1] 120 $wday [1] 0 $yday [1] 88 $isdst [1] 0 $zone [1] \"UTC\" $gmtoff [1] 0 attr(, \"tzone\") [1] \"\" \"UTC\" \"UTC\" 与所有 POSIXlt 对象一样，t2 是一个由日期和时间组成的列表。使用 str(unclass(t2)) 获得更紧凑的预览。 > str(unclass(t2)) List of 11 $ sec : num 31 $ min : int 58 $ hour : int 8 $ mday : int 29 $ mon : int 2 $ year : int 120 $ wday : int 0 $ yday : int 88 $ isdst : int 0 $ zone : chr \"UTC\" $ gmtoff: int 0 - attr(*, \"tzone\")= chr [1:3] \"\" \"UTC\" \"UTC\" 例如，如果我们只需要存储在 t2 中时间的分钟数，我们可以使用 t2$min 访问他们。试试吧。 > t2$min [1] 58 现在我们已经探索了日期和时间对象的三种类型，接下来让我们看一些可以从这些对象中提取有用信息的一些函数，weekday()，month() 和 quarter()。 > weekdays(d1) [1] \"Sunday\" > months(t1) [1] \"March\" > quarters(t2) [1] \"Q1\" 通常，数据集中的日期和时间是 R 中不认识的格式。在这种情况下，strptime() 函数很有用。 strptime() 将字符向量转换为 POSIXlt。在这个意义上，它类似于 as.POSIXlt()，只是不必输入特定的格式 （YYYY-MM-DD）。 我们创建一个变量来看一下它是如何发挥作用的。 > t3 t4 t4 [1] \"1986-10-17 08:24:00 UTC\" 我就是我们期待的格式。现在，我们来检查下它的类别。 > class(t4) [1] \"POSIXlt\" \"POSIXt\" 最后，您可以对日期和时间执行许多操作，包括算术运算（+和-）和比较运算（ 变量 t1 是您之前使用 Sys.time() 创建的时间对象。我们可以使用 > 操作运算符将其与当前时间比较。 > Sys.time() > t1 [1] TRUE 我们也可以执行算术运算。 > Sys.time() - t1 Time difference of 1.13737 hours 同样的思路也适用于加法和其他比较运算符。如果您希望在查看上述时间差异是对时间有更多的控制权，您可以使用 difftime() 函数，它允许您指定一个 单位 参数。 使用 difftime(Sys.time(), t1, units = 'days') 来查看自从创建 t1 过去了总共多少天。 > difftime(Sys.time(), t1, units = 'days') Time difference of 0.05028701 days 在这节课中，你学习了如何在 R 中处理日期和时间。虽然了解这些基础知识很重要，但是如果你发现自己经常处理日期和时间数据，你可能会想看看 Hadley Wickham 的 lubridate 软件包。 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 15:56:20 "},"R/RProgramming/lesson15.html":{"url":"R/RProgramming/lesson15.html","title":"基本图形","keywords":"","body":"Lesson 15: 基本图形 本课总结 data() 函数载入数据 plot() 绘制散点图，R 能够自动将二列数据作为坐标轴，但最好的方式是明确地利用参数指定相应的 x 轴和 y 轴。当然也可以使用 formula 对象的方式，formula = dist ~ speed 的对应的位置是 y ~ x，所以 plot(dist ~ speed, cars) 绘制的图形是以 dist 作为 y 轴，speed 作为 x 轴。 plot() 函数常用的参数包括，main 标题，sub 副标题，xlab x 轴标签，ylab y 轴标签，col 颜色，pch 指定形状等等。 boxplot 绘制箱图，用法与 plot 一致，例 boxplot(mpg ~ cyl, mtcars) hist 函数绘制直方图，但最好只使用一个参数，如 hist(mtcars$mpg) 本课详细内容 和其他编程语言相比，R 最大的优点之一是可以轻松绘图。在本节课，您将学习 R 语言中的基本图形。 在本课中，我们不涉及 lattice，ggplot2 以及 ggvis 等图形学中更高级的部分。 有一种学派认为我们应该先教 ggplot2。参见 http://varianceexplained.org/r/teach_ggplot2_to_beginners/ 使用 data(cars) 载入 cars 数据框。 > data(cars) 为了解决问题，我们将使用简单的数据框。我们的主要目标是介绍各种绘图函数及其参数。对于更大、更复杂的数据集，输出结果看起来会更有趣。 打开 cars 的帮助页面。正如您在帮助页面看到的，cars 数据仅有两个变量 speed 和 stopping distance。注意，数据来自二十世纪二十年代。 运行 head() 函数预览数据。 > head(cars) speed dist 1 4 2 2 4 10 3 7 4 4 7 22 5 8 16 6 9 10 在绘图之前，先了解数据是个好注意。可以使用 dim()，names()，tail() 以及 summary() 函数。 对数据框运行 plot() 函数。 > plot(cars) 和往常一样，根据您提供的信息，R 非常努力地给您输出一些合理的东西。首先，R 注意到您给他提供的数据只有两列，所以它假设你想要画出一列和另一列。 其次，由于我们没有为任何一个轴提供标签，R 使用了列的名称。第三，它在标签的整数上创建轴标记。第四，它使用 plot() 函数中提供的其他默认值。注意，plot 是 scatterplot 的缩写。 查看 plot() 函数的帮助页面。（略） plot() 的帮助页面突出显示了函数可以接受的不同参数。最重要的两个是 x 和 y，这两个变量将绘制出来。对于下一组问题，答案中包含了参数。也就是，不要键入 plot(cars$speed, cars$dist) ，尽管这样做也是可行的。我们应该使用 plot(x= cars$speed, y= cars$dist)。 使用 plot() 命令绘图，使 x 轴上显示 cars 的速度，y 轴上显示其距离。 > plot(x = cars$speed, y = cars$dist) 注意，这条指令和 plot(cars) 有点点不同。在这个案例中，R 不确定你想把什么作为 x 轴的标签，因此你需要使用参数传递给它这个信息，其中应该包括数据框的名称以及 $ 符号。 注意，还有其他的方式调用 plot 命令，即使用 formula 接口。例如，我们得到了与上面类似的 plot(dist ~ speed, cars)。我们会在本课的后面部分使用 formula 接口。 下面使用 plot() 命令，将 dist 设为 x 轴，将 y 轴设为 speed。这和上面的相反。 > plot(x = cars$dist, y = cars$speed) 速度设为 x 轴可能更有意义，因为停止距离是速度的函数，而反过来未必。所以，本课程剩下的问题，是要相应地分配合适的参数。 你可以假设接下来的几个问题的答案都是 plot(x = cars$speed, y = cars$dist, ...)，使用各种参数代替 ... 设置 x 轴的标签为 Speed 来重新绘图。 > plot(x = cars$speed, y = cars$dist, xlab = 'Speed') 将 y 轴的标签设置为 Stop Distance。 > plot(x = cars$speed, y = cars$dist, ylab = 'Stopping Distance') 将 x 轴和 y 轴的标签分别设置为 Speed 和 Stopping Distance。 > plot(x = cars$speed, y = cars$dist, xlab = 'Speed', ylab = 'Stopping Distance') 在本课程开始的时候，plot(cars) 能生效的原因是 R 最够聪明，它第一个元素（即第一列）应该赋值为 x 参数，而第二个元素赋值给 y 参数。下面可以使用 plot(cars, ...) 来简化输入，并添加各种参数。当然，我们可以只指定一个参数，也可以指定多个参数。 为图形添加标题 My Plot。 > plot(cars, main = 'My Plot') 为图形添加副标题 My Plot Subtitle。 > plot(cars, sub = 'My Plot Subtitle') 下面开始探索一些其他的选项，请查看 ?par 。让我们来看看一些更常用的选项。继续使用 plot(cars, ...) 为基础回答问题。 将图线绘制成红色。（使用参数 col = 2） > plot(cars, col = 2) 限制 x 轴的范围为 10-15 之间。（使用 xlim = c(10, 15) 来达到这个效果） > plot(cars, xlim = c(10, 15)) 你也可以改变符号的形状，详细信息请参考 ?point。下面我们把符号改成三角形。（使用参数 pch = 2） > plot(cars, pch = 2) 许多人现在使用更高级的包，比如 ggplot2，来创建图形。我们介绍 R 内置的绘图函数仍然是有用的，因为许多人在 lattice 和 ggplot2 中的习惯用法都是建立在它的基础上的。 现在，让我们看看基本图形中其他一些可能有用的函数，从箱型图（boxplots）开始。 载入 matcars 数据框的数据。 > data(mtcars) 每当您加载一个新的数据框时，都应该在使用之前先研究它。在之前的课程中提到，可以使用 dim() 和 head() 之类的函数。 boxplot 函数和许多 R 内置函数一样，也可以采用 formula 参数。使用 formula = mpg ~ cyl 和 data = mtcars 来创建一个 boxplot。 > boxplot(mpg ~ cyl, mtcars) 从图中可以看出，多缸车的 mpg 值要低得多。注意，我们可以使用与上面的 plot() 相同的一组参数来添加坐标轴标签，标题等等。 当观察单个变量时，直方图是一个非常有用的工具。hist() 是一个相关的 R 函数。hist() 最好的用法是只传递单个向量作为参数。 下面使用 hist() 函数和 mtcars$mpg 参数来创建一个直方图。 > hist(mtcars$mpg) 本节课，您学习了如何在 R 中绘图。下一步最好的选择是从这里开始学习 ggplot2，如果您想了解基本图形的其他元素，那么这个 页面 可以为您提供一个参考。 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 15:56:20 "},"R/RegressionModels/":{"url":"R/RegressionModels/","title":"回归模型","keywords":"","body":"回归模型 Copyright © xresearcher.com 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-03-31 16:10:10 "}}