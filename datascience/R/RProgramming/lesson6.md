# Lesson 6: 子集向量
在这节课中，我们将看到如何根据我们指定的一些条件从向量中提取元素。

例如，我们也许只对一个向量的前 20 个元素感兴趣，活着仅对那些不是 NA 的元素感兴趣，或者只对那些是正的或者对应于一个特定的感兴趣的元素感兴趣。本课结束时，你将了解如何处理这些场景。

我们已经创建了一个向量 x，它包含了从标准正态分布中随机选取的 20 个数字，以及 20 个 NA。现在输入 x，看它是否是这样的：
~~~r
> x
 [1]          NA          NA -0.01301518          NA          NA          NA
 [7] -0.47721718          NA  0.23556194          NA          NA          NA
[13] -0.56827616          NA -1.39451656  0.20122132  0.09755386  2.47619742
[19] -0.08464506  0.80707804 -0.28220555 -0.85445817  1.65740981          NA
[25]          NA  0.19560065          NA          NA -0.84176773  0.30555518
[31]          NA  0.27902072          NA          NA  0.91157021          NA
[37]          NA -0.70343162          NA -0.64953318
~~~
你告诉 R 你想从向量中选择一部分元素(比如：一个子集)的方法是在向量的名字后面的方括号中放置一个“索引向量”。

比如一个简单的例子，试一下 `x[1:10]` 来查看向量 x 的前 10 个元素。
~~~r
> x [1:10]
 [1]          NA          NA -0.01301518          NA          NA          NA
 [7] -0.47721718          NA  0.23556194          NA
~~~
索引向量有四种不同的形式：逻辑向量，正整数的向量，负整数的向量，字符串的向量。每一个我们在这节课都会讲到。
## 逻辑向量
让我们从逻辑向量建立索引开始。在处理真实数据时，一个常见的场景时我们想要提取一个向量中不是 NA 的所有元素。回想一下，`is.na(x)` 生成了一个长度于 x 相同的逻辑值向量，其 TRUE 对应于 x 中的 NA，FALSE 对应于 x 中的非 NA 值。

考虑一下，`x[is.na(x)]` 会返回什么结果：
~~~r
> x [is.na(x)]
 [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
~~~
提取的是所有的 NA 值。

回想一下，`!` 给我们一个逻辑表达式的否定式，所有 `!is.na(x)` 可以被解读为 `is not NA`。因此，我们想要创建一个包含所有来自 x 的非 NA 值的向量 y，我们可以使用 `y <- x[!is.na(x)]`, 试试吧：
~~~r
> y <- x[! is.na(x)]
> y
 [1]  1.58802569 -1.01293755  0.37155713  1.69750561 -1.60847397  0.60249903
 [7] -0.41862256 -0.48870077  1.18646771 -0.54252969 -0.97333657  1.13544799
[13]  0.06677423  0.56186192  0.16981586 -1.26339820 -0.78870739 -0.41639811
[19] -0.17735571 -2.33724788
~~~
现在我们已经隔离了 x 的非缺失值，并将它们放入 y 中，子集 y 就是我们想要的。

回想一下，表达式 `y > 0` 将给我们一个逻辑值向量，它的长度与 y 相同，TRUE 对应于大于 0 的 y 的值，FALSE 对应于小于等于 0 的 y 的值。你认为 `y[y > 0]` 会返回什么？试一下：
~~~r
> y [y > 0]
[1] 1.58802569 0.37155713 1.69750561 0.60249903 1.18646771 1.13544799 0.06677423
[8] 0.56186192 0.16981586
~~~
你也许想知道为什么我们一开始不用 `x[x > 0]` 来提取 x 中的正值元素，试一下看下结果：
~~~r
> x [x > 0]
 [1]         NA         NA         NA 1.58802569         NA         NA
 [7] 0.37155713         NA 1.69750561         NA 0.60249903         NA
[13]         NA         NA 1.18646771         NA         NA 1.13544799
[19]         NA 0.06677423         NA         NA 0.56186192 0.16981586
[25]         NA         NA         NA         NA         NA
~~~
因为 NA 不是一个值，而是一个未知数的占位符，所以表达式 `NA > 0` 的结果为 NA。因此，当我们这样做的时候，我们得到了一堆和我们的正数混合在一起的 NA。

结合逻辑运算和子集的知识，我可以这样做，`x[!is.na(x) & x > 0]`，试一下：
~~~r
> x [! is.na(x) & x > 0]
[1] 1.58802569 0.37155713 1.69750561 0.60249903 1.18646771 1.13544799 0.06677423
[8] 0.56186192 0.16981586
~~~
在本例中，我们只请求了非缺失值且大于零的 x 值。

我已经向您展示了如何使用 `x[1:10]` 来子集化 x 的前十个值。在本例中，我们在方括号内提供了一个正整数向量，它告诉 R 只返回编号为 1 到 10 的 x 的元素。

许多编程语言使用所谓的“从零开始的索引”，这意味着向量的第一个元素被认为是元素 0。R 使用“基于 1 的索引”，这意味着一个向量的第一个元素被认为是元素 1。

您能指出我们如何将x的第3、5和7个元素子集化吗? 提示：使用`c()`函数将元素编号指定为数字向量。
